# 🚀 C++ 대탐험: 9개의 모듈로 완성하는 객체 지향의 세계!

안녕하세요! 오늘은 제가 42서울 과정에서 C++의 광활한 세계를 탐험했던 여정을 총정리해보려고 해요. `C++ Module 00`부터 `08`까지, 각 모듈은 C++의 특정 개념을 깊이 있게 파고드는 작은 프로젝트들로 이루어져 있었답니다. 마치 헬스 트레이너가 부위별 운동을 시키듯, C++의 근육을 하나하나 단련하는 느낌이었죠. (덕분에 제 코딩 근육도 제법 탄탄해졌답니다! 💪)

이 대장정을 통해 저는 C언어의 절차적 프로그래밍에서 벗어나, **객체 지향 프로그래밍(OOP)**의 세계에 눈을 뜨고, **템플릿**, **예외 처리**, **STL** 등 C++의 강력한 기능들을 직접 구현하고 사용하며 체득할 수 있었어요.

## 🗺️ 모듈별 탐험 일지: 한 걸음씩, 깊이 있게!

각 모듈은 저에게 새로운 도전과 깨달음을 안겨주었어요.

### 🔹 **Module 00: C++의 첫인사**

-   **핵심:** C++의 기본 입출력(`iostream`), 네임스페이스, 클래스와 객체의 아주 기본적인 개념을 익혔어요.
-   **프로젝트:** `megaphone` (문자열 대문자 변환), `phonebook` (간단한 연락처 관리 프로그램) 등을 만들며 C언어와는 다른 C++의 기본적인 스타일을 맛봤죠. `Account` 클래스를 구현하면서는 클래스의 멤버 변수와 함수, `static` 멤버의 개념을 처음 접했답니다.

### 🔹 **Module 01: 메모리와 참조의 세계**

-   **핵심:** `new`와 `delete`를 이용한 동적 할당, 포인터와 참조자(reference)의 차이, 함수 포인터 등 C++의 메모리 관리 방식을 깊이 있게 다뤘어요.
-   **프로젝트:** `Zombie` 클래스를 통해 객체의 동적 생성과 소멸을 연습했고, `Human`과 `Weapon` 예제를 통해 객체 간의 관계와 참조자의 유용성을 체감했죠. 파일 입출력을 다루는 과제도 있었는데, `ifstream`과 `ofstream`을 사용하며 C++ 스타일의 파일 처리에 익숙해졌어요.

### 🔹 **Module 02: 연산자 오버로딩과 고정 소수점**

-   **핵심:** 연산자 오버로딩(operator overloading)이라는 강력한 기능을 통해 클래스를 마치 기본 자료형처럼 다룰 수 있게 만드는 방법을 배웠어요.
-   **프로젝트:** `Fixed` 클래스를 만들어 고정 소수점(fixed-point number)을 구현하는 과제가 백미였죠. `+`, `-`, `*`, `/` 같은 산술 연산자는 물론, `++`, `--`, 비교 연산자까지 모두 오버로딩하며 C++의 다형성(polymorphism)을 제대로 느낄 수 있었답니다.

### 🔹 **Module 03: 상속의 미학**

-   **핵심:** 객체 지향의 꽃, 상속(inheritance)을 배웠어요. `ClapTrap`이라는 기본 클래스를 만들고, 이를 상속받는 `ScavTrap`, `FragTrap`을 만들었죠.
-   **프로젝트:** 마지막에는 `ScavTrap`과 `FragTrap`을 다중 상속받는 `DiamondTrap`을 구현하며, 다이아몬드 상속 문제(Diamond Problem)와 가상 상속(virtual inheritance)의 필요성까지 경험하는, 정말 깊이 있는 학습이었어요.

### 🔹 **Module 04: 다형성과 추상 클래스**

-   **핵심:** 상속의 개념을 더욱 확장시켜, 가상 함수(virtual function)를 이용한 동적 바인딩과 다형성을 구현했어요.
-   **프로젝트:** `Animal`이라는 추상 기본 클래스(Abstract Base Class)를 만들고, 순수 가상 함수(`= 0`)를 통해 파생 클래스(`Dog`, `Cat`)가 반드시 구현해야 할 인터페이스를 정의했죠. 이를 통해 "기반 클래스 포인터로 파생 클래스 객체를 다루는" 객체 지향의 진정한 힘을 느낄 수 있었답니다.

### 🔹 **Module 05: 예외 처리와 중첩 클래스**

-   **핵심:** 프로그램 실행 중 발생할 수 있는 오류를 우아하게 처리하는 방법, 바로 예외 처리(`try`, `catch`, `throw`)를 배웠어요.
-   **프로젝트:** `Bureaucrat`(관료)과 `Form`(서식) 클래스를 만들며, 등급이 맞지 않는 등의 예외 상황을 직접 정의한 예외 클래스를 던져 처리하는 연습을 했죠. 또한, `Intern` 클래스를 통해 폼을 '생산'하는 팩토리 패턴(Factory Pattern)과 유사한 개념도 접해볼 수 있었어요.

### 🔹 **Module 06: C++ 스타일 캐스팅**

-   **핵심:** C언어 스타일의 무분별한 형변환 대신, C++이 제공하는 4가지 타입 캐스팅(`static_cast`, `dynamic_cast`, `const_cast`, `reinterpret_cast`)의 용도와 차이점을 명확히 이해했어요.
-   **프로젝트:** `dynamic_cast`를 이용해 기반 클래스 포인터가 실제로 어떤 파생 클래스 객체를 가리키는지 런타임에 확인하는 과제를 통해, 안전한 다운캐스팅의 중요성을 배웠답니다.

### 🔹 **Module 07: 템플릿의 마법**

-   **핵심:** C++의 가장 강력한 기능 중 하나인 템플릿(template)을 본격적으로 다뤘어요. 함수 템플릿과 클래스 템플릿을 이용해, 자료형에 구애받지 않는 범용적인 코드를 작성하는 방법을 익혔죠.
-   **프로젝트:** `swap`, `min`, `max` 같은 함수 템플릿과, 배열을 템플릿 클래스로 감싸는 `Array` 클래스를 직접 구현하며 제네릭 프로그래밍(Generic Programming)의 기초를 다졌습니다.

### 🔹 **Module 08: STL 컨테이너와 알고리즘**

-   **핵심:** 드디어 C++ 표준 템플릿 라이브러리(STL)의 컨테이너들을 직접 사용해보는 시간! `vector`, `list`, `map` 등 다양한 컨테이너의 특징을 이해하고, `iterator`와 알고리즘을 활용하는 방법을 배웠어요.
-   **프로젝트:** `easyfind` 함수를 만들어 컨테이너에서 특정 값을 찾는 알고리즘을 구현하고, `Span` 클래스를 통해 많은 숫자를 저장하고 그 안에서 최대/최소 범위를 찾는 등 STL의 강력함을 마음껏 활용했답니다. `MutantStack` 과제는 `std::stack`을 상속받아 이터레이터를 추가하는 재미있는 경험이었죠.

## ✨ 대장정을 마치며

C++ 모듈 00부터 08까지의 여정은 결코 쉽지 않았지만, C++이라는 언어를 단순한 'C언어의 확장판'이 아닌, 깊은 철학을 가진 강력한 도구로 바라보게 된 계기가 되었어요. 각 모듈을 클리어할 때마다 C++의 새로운 면모를 발견하는 재미가 쏠쏠했답니다. 이 경험은 앞으로 제가 어떤 프로그래밍 언어를 만나든 그 내부를 깊이 있게 이해하려는 좋은 습관을 만들어 주었다고 생각해요! 😊
