네, 알겠습니다. `ft_transcendance`는 42 과정의 대미를 장식하는 종합 프로젝트인 만큼, 그 중요성과 기술적 깊이를 충분히 담아내기 위해 웹 개발 아키텍처의 핵심 원리를 중심으로 상세하게 v2 문서를 작성했습니다.

***

## ✨ ft_transcendance: 풀스택 웹 애플리케이션 아키텍처의 완성

`ft_transcendance`는 42 과정에서 배운 모든 지식을 총동원하여, 현대적인 기술 스택 위에서 실시간 상호작용이 가능한 풀스택(Full-stack) 웹 애플리케이션을 처음부터 끝까지 설계하고 구축하는 대장정이다. 이 프로젝트의 본질은 단순히 특정 프레임워크 사용법을 익히는 것을 넘어, **분리된 프론트엔드와 백엔드, 데이터베이스를 컨테이너 기술로 묶어 하나의 유기적인 서비스로 조율하는 현대 웹 아키텍처**에 대한 깊은 이해를 요구한다.

채팅과 실시간 PING-PONG 게임이라는 요구사항은, 일반적인 CRUD(Create, Read, Update, Delete) 애플리케이션의 한계를 넘어 **실시간 양방향 통신(WebSocket)**, **상태 동기화(State Synchronization)**, **서버 권위적(Server-Authoritative) 로직**과 같은 고수준의 엔지니어링 과제를 해결하도록 이끈다.

---

### 📜 1. 기술 스택과 아키텍처 설계 철학

`ft_transcendance`의 기술 스택은 각 계층의 역할을 명확히 분리하고, 유지보수성과 확장성을 극대화하는 방향으로 선택되었다.

* **백엔드 - NestJS (Node.js)**:
    * **설계 철학**: **제어의 역전(IoC)**과 **의존성 주입(DI)** 패턴을 프레임워크 수준에서 적극적으로 활용하여, 모듈 기반의 확장 가능한 아키텍처를 제공한다. 이는 각 기능(사용자, 채팅, 게임)을 독립적인 모듈로 개발하고 테스트하기 용이하게 만들어, 대규모 애플리케이션의 복잡성을 효과적으로 관리하게 한다. TypeScript를 기본으로 사용하여 정적 타입의 안정성을 확보한 것 또한 중요한 선택 이유이다.
    * **ORM - TypeORM**: 데이터베이스와의 상호작용을 객체 지향적으로 처리하기 위해 **ORM(Object-Relational Mapper)**을 사용한다. SQL 쿼리를 직접 작성하는 대신 TypeScript 클래스와 데코레이터를 통해 데이터베이스 스키마와 관계를 정의하고 조작함으로써, 개발 생산성과 코드의 안정성을 높인다.

* **프론트엔드 - Next.js (React)**:
    * **설계 철학**: 사용자 경험(UX)과 검색 엔진 최적화(SEO)를 고려하여 **서버 사이드 렌더링(SSR)**과 **정적 사이트 생성(SSG)**을 지원한다. 초기 페이지 로딩 시 서버에서 완성된 HTML을 전달하여 클라이언트 측 렌더링(CSR) 방식의 단점인 긴 초기 로딩 시간을 개선한다. React의 컴포넌트 기반 개발 방식은 복잡한 UI를 재사용 가능한 조각으로 나누어 관리하는 데 효과적이다.

* **인프라 - Docker & Docker Compose**:
    * **설계 철학**: 개발, 테스트, 프로덕션 환경의 차이로 인해 발생하는 문제를 원천적으로 차단하기 위해 **컨테이너화(Containerization)**를 채택한다. 백엔드, 프론트엔드, 데이터베이스를 각각 격리된 컨테이너로 패키징하여, 어디서든 동일한 환경에서 애플리케이션을 실행할 수 있도록 보장한다. `docker-compose.yml`은 이 모든 서비스의 구성과 관계를 정의하는 **선언적(Declarative) 명세서** 역할을 한다.

---

### 🎯 2. 핵심 기능의 심층 분석

#### 가. 사용자 인증 (Authentication & Authorization)

* **42 Intra OAuth 2.0**: 인증(Authentication)의 시작점으로, 신뢰할 수 있는 제3자(42 Intra)에게 인증을 위임하는 **OAuth 2.0** 프로토콜을 구현한다. 이를 통해 서비스는 사용자의 민감한 크리덴셜을 직접 저장할 필요 없이 안전하게 사용자를 식별할 수 있다.
* **JWT (JSON Web Token) 기반의 무상태(Stateless) 세션**: 인증 성공 후, 서버는 사용자의 정보를 담아 암호학적으로 서명된 **JWT**를 발급한다. 클라이언트는 이 토큰을 저장해두고, 이후 모든 API 요청의 `Authorization` 헤더에 담아 전송한다. 서버는 데이터베이스 조회 없이 토큰의 서명만으로 사용자를 검증할 수 있으므로, 세션 상태를 서버에 저장할 필요가 없는 **무상태(Stateless) 인증**을 구현할 수 있다. 이는 서버의 수평적 확장에 매우 유리한 구조이다.
* **2단계 인증 (2FA)**: 보안 강화를 위해 **TOTP(Time-based One-Time Password)** 알고리즘을 기반으로 한 2단계 인증을 구현한다. 사용자는 인증 앱(Google Authenticator 등)을 통해 생성된 일회용 비밀번호를 추가로 입력해야만 로그인이 완료된다.

#### 나. 실시간 양방향 통신 (Real-time Bidirectional Communication)

* **WebSocket의 채택**: 채팅이나 실시간 알림과 같이 서버와 클라이언트 간의 즉각적인 양방향 통신이 필요한 기능을 위해 **WebSocket**을 사용한다. 기존의 HTTP 폴링(Polling) 방식이 가지는 불필요한 요청 오버헤드와 지연 시간 문제를 해결하고, 하나의 TCP 연결 위에서 양방향으로 데이터를 전송하는 효율적인 통신 채널을 구축한다. **Socket.IO** 라이브러리는 WebSocket을 기반으로, 필요시 HTTP Long-Polling으로 자동 전환되는 기능과 `Room`, `Namespace` 같은 편리한 추상화 계층을 제공한다.

#### 다. 실시간 게임 플레이 (Real-time Gameplay)

* **서버 권위적(Server-Authoritative) 아키텍처**: 온라인 게임의 공정성과 보안을 보장하기 위한 표준적인 설계이다. 게임의 모든 핵심 상태(공의 위치, 속도, 플레이어 점수 등)는 오직 **서버**만이 계산하고 변경할 수 있는 권한을 가진다.
* **동작 방식**: 클라이언트는 사용자의 입력(예: '패들 위로 이동')만을 서버에 전송하는 역할을 한다. 서버는 이 입력을 받아 게임 물리 엔진을 실행하고, 갱신된 게임 상태를 모든 클라이언트에게 주기적으로 브로드캐스팅한다. 클라이언트는 서버로부터 받은 상태를 화면에 그리기만 하는 '덤 클라이언트(Dumb Client)'의 역할을 수행한다. 이 구조는 클라이언트 측에서 게임 데이터를 조작하는 **치팅 행위를 원천적으로 방지**하고, 모든 플레이어가 동기화된 게임 경험을 하도록 보장한다.

---

### 🤔 성찰 및 배운 점

`ft_transcendance`는 웹 기술의 파편적인 지식들을 하나의 완성된 아키텍처로 엮어내는 종합적인 설계 능력을 길러준 프로젝트였다.

* **풀스택 개발의 전체적인 시야**: 데이터베이스 스키마 설계부터 백엔드 API 및 소켓 로직 구현, 그리고 프론트엔드의 상태 관리와 UI 렌더링에 이르기까지, 웹 애플리케이션 개발의 전 과정을 관통하는 경험을 통해 각 기술 요소가 어떻게 상호작용하는지에 대한 거시적인 시각을 확보했다.
* **실시간 시스템의 복잡성 이해**: 실시간 애플리케이션은 상태 동기화, 지연 시간(Latency) 보정, 비동기 이벤트 처리 등 일반적인 웹사이트와는 차원이 다른 복잡성을 가진다는 것을 체감했다. 서버와 클라이언트 간의 수많은 메시지 흐름을 디버깅하며 문제 해결 능력을 크게 향상시킬 수 있었다.
* **컨테이너 기반 개발 워크플로우의 체화**: Docker를 통한 환경 격리와 `docker-compose`를 이용한 서비스 오케스트레이션은, 이제는 현대적인 개발 환경에서 선택이 아닌 필수임을 깨달았다. 이는 협업의 효율성을 극대화하고, "내 컴퓨터에선 되는데..."라는 고질적인 문제를 해결하는 가장 확실한 방법이다.

이 프로젝트를 통해 얻은 경험은, 단순히 특정 기술 스택에 대한 숙련도를 넘어, 복잡한 요구사항을 안정적이고 확장 가능한 소프트웨어 아키텍처로 구현해내는 시스템 설계자로서의 역량을 다지는 굳건한 발판이 되었다.