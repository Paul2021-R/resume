## 💻 Minishell: 운영체제의 축소판, 텍스트와 프로세스 사이의 번역가를 자처하다

통곡의 벽.
수 많은 42서울의 과제들 과정에서도, 역대급으로 고민하고, 소통할 일이 많아지는 프로젝트. 
쉽지 않았던 이 프로젝트는 지금도 두고두고 생각나는, 정말 쉽지 않은 '험한 것' 이었다.

-- 작업 내역 ---

이전의 과제들이 개별적인 시스템 콜이나 동기화 메커니즘을 깊게 파고드는 경험이었다면, **Minishell**은 이 모든 것을 아우르는 하나의 작은 운영체제를 설계하고 구현하는 종합적인 과제이다. 셸(Shell)은 단순히 명령어를 실행하는 프로그램을 넘어, 커널(Kernel)이라는 시스템의 심장부와 사용자 사이를 연결하는 정교한 인터페이스이자 번역가이다. 사용자가 입력한 한 줄의 텍스트 문자열이 어떻게 생명력을 얻어 여러 프로세스의 협연으로 재탄생하는지, 그 모든 과정을 직접 지휘해야 하는, 시스템 프로그래머로서의 진정한 역량을 시험받는 프로젝트이다.

`Minishell`은 "어떻게 문자열을 해석하고(Parsing), 어떻게 프로세스를 생성하며(Process Management), 어떻게 그들 간의 데이터 흐름을 제어할 것인가(IPC & I/O Redirection)"라는 세 가지 거대한 질문에 대한 답을 찾아가는 여정이다.

---

### 📜 1단계: 문자열 해석 (Parsing) - 무의미한 텍스트에서 의미 있는 구조로

셸의 첫 번째 임무는 `ls -al | grep "main" > result.txt`와 같이 인간에게는 익숙하지만 컴퓨터에게는 의미 없는 문자열 덩어리를, 컴퓨터가 이해할 수 있는 구조적인 데이터로 변환하는 것이다. 이는 작은 프로그래밍 언어의 컴파일러를 만드는 과정과 유사하며, 크게 두 단계로 나뉜다.

1.  **어휘 분석 (Lexical Analysis / Tokenization)**:
    [cite_start]입력된 문자열을 `ls`, `-al`, `|`, `grep`, `"main"`, `>`, `result.txt` 와 같이 의미를 가진 최소 단위인 **토큰(Token)**으로 분해한다[cite: 1]. 이 과정에서 공백은 분리의 기준이 되며, 파이프(`|`)나 리다이렉션(`>`, `<`) 같은 특수 문자는 '연산자' 토큰으로, 따옴표로 묶인 문자열은 하나의 단일 토큰으로 인식하는 등 정교한 규칙이 필요하다.

2.  **구문 분석 (Syntax Analysis / Parsing)**:
    생성된 토큰의 배열을 바탕으로, 명령어의 문법적 구조를 파악하여 **추상 구문 트리(Abstract Syntax Tree, AST)**와 같은 자료구조를 생성한다. 예를 들어, `A | B > C` 라는 명령어는 '파이프'라는 최상위 노드를 가지고, 그 왼쪽 자식으로는 'A'라는 간단한 명령어(Simple Command) 노드가, 오른쪽 자식으로는 '리다이렉션' 노드가 연결되는 형태가 된다. 이 트리를 통해 각 명령어의 관계와 실행 순서, 입출력 방향이 명확하게 정의된다. 이 과정에서 닫히지 않은 따옴표나 문법에 맞지 않는 특수문자 사용과 같은 구문 오류를 잡아내는 것도 파서의 중요한 역할이다.

* **따옴표와 환경 변수 처리**: 파싱 과정에서 셸의 미묘한 규칙들을 구현해야 한다.
    * [cite_start]**작은따옴표(`'`)**는 내부의 모든 문자를 해석 없이 문자 그대로 취급한다[cite: 1].
    * [cite_start]**큰따옴표(`"`)**는 내부의 `$` 문자를 환경 변수로 인식하여 그 값으로 **치환(Expansion)**해야 한다[cite: 1]. [cite_start]`$?`와 같이 마지막으로 실행된 명령어의 종료 코드를 나타내는 특수한 환경 변수도 처리해야 한다[cite: 1].

---

### 🛠️ 2단계: 명령어 실행 (Execution) - 구조화된 명령에 생명을 불어넣다

구문 분석을 통해 만들어진 실행 계획(AST)을 이제 실제 동작으로 옮길 시간이다. 실행기는 트리를 순회하며 각 노드의 타입에 따라 적절한 시스템 콜을 호출하는 역할을 한다.

1.  **프로세스 생성 (`fork`)**:
    `ls`, `grep`과 같은 외부 명령어를 실행하기 위해 `fork()` 시스템 콜로 현재 셸 프로세스와 똑같은 자식 프로세스를 생성한다. 이후 자식 프로세스는 `execve()` 시스템 콜을 통해 자기 자신을 새로운 프로그램(`ls` 등)으로 교체하여 실행한다. 부모 프로세스(셸)는 `waitpid()`를 통해 자식 프로세스가 종료되기를 기다렸다가, 제어권을 다시 가져와 다음 명령을 받을 준비를 한다.

2.  **파이프 (`|`) - 프로세스 간 통신 (IPC)**:
    [cite_start]`pipe()` 시스템 콜은 두 개의 파일 디스크립터(읽기용, 쓰기용)를 생성하여 프로세스 간 통신 채널을 만단다[cite: 1]. `A | [cite_start]B` 구문에서, 셸은 파이프를 생성한 후 두 개의 자식 프로세스를 만든다[cite: 1].
    * **프로세스 A**: 자신의 표준 출력(STDOUT, fd 1)을 파이프의 쓰기용 끝에 연결(`dup2`)하고, `A` 명령어를 실행한다. `A`의 모든 결과는 이제 화면이 아닌 파이프로 흘러 들어간다.
    * **프로세스 B**: 자신의 표준 입력(STDIN, fd 0)을 파이프의 읽기용 끝에 연결(`dup2`)하고, `B` 명령어를 실행한다. `B`는 이제 키보드가 아닌 파이프로부터 데이터를 입력받아 처리한다.

3.  **리다이렉션 (`<`, `>`, `>>`, `<<`) - 파일 디스크립터 제어**:
    [cite_start]리다이렉션은 프로세스의 표준 입출력 대상을 파일로 변경하는 기술이다[cite: 1]. 이는 `open()`으로 파일을 열고, `dup2()`로 기존의 표준 입출력 파일 디스크립터(0, 1, 2)를 새로 열린 파일의 디스크립터로 복제하는 방식으로 구현된다.
    * [cite_start]`>`: 명령어의 결과를 파일에 덮어쓴다[cite: 1].
    * [cite_start]`<`: 파일의 내용을 명령어의 입력으로 사용한다[cite: 1].
    * [cite_start]`>>`: 명령어의 결과를 파일 끝에 추가한다[cite: 1].
    * [cite_start]`<< (Here Document)`: 구분자(delimiter)가 나올 때까지 입력을 받아 임시 파일에 저장한 후, 해당 임시 파일을 표준 입력으로 리다이렉션하는 방식으로 구현된다[cite: 1].

4.  **내장 함수 (Built-ins)**:
    `cd`, `export`, `unset`, `exit`와 같이 셸 프로세스 자체의 상태(현재 작업 경로, 환경 변수 등)를 변경해야 하는 명령어들은 외부 프로그램으로 실행할 수 없다. `cd`를 자식 프로세스에서 실행하면 자식의 경로만 바뀌고 셸 자신은 그대로이기 때문이다. 따라서 이는 `fork` 없이 셸이 직접 함수 호출을 통해 처리해야 한다. `README.md`에 명시된 `echo`, `cd`, `pwd`, `export`, `unset`, `env`, `exit`가 이에 해당한다.

---

### 🚦 3단계: 시그널 처리 - 예기치 않은 상황에 대응하기

사용자는 언제든지 `Ctrl+C`(SIGINT)나 `Ctrl+D`(EOF)를 눌러 프로세스를 제어하려 할 수 있다. [cite_start]상호작용적인 셸은 이러한 시그널을 적절히 처리하여, 자식 프로세스가 실행 중일 때와 프롬프트에서 입력을 대기 중일 때 다르게 동작하도록 설계해야 한다[cite: 1]. `signal` 또는 `sigaction` 함수를 통해 특정 시그널이 도착했을 때 수행할 동작을 정의하여, 프로그램의 안정성과 사용자 경험을 향상시켜야 한다.
* [cite_start]**대기 중**: `Ctrl+C`는 새 프롬프트를, `Ctrl+D`는 셸을 종료한다[cite: 1].
* **실행 중**: `Ctrl+C`와 `Ctrl+\`는 실행 중인 자식 프로세스에게 전달되어야 한다.

---

### ✨ 성찰 및 배운 점

`Minishell`은 단순한 C 프로그래밍 과제가 아니었다. 그것은 운영체제가 어떻게 사용자 요청을 처리하고, 프로세스들을 조율하며, 데이터의 흐름을 관리하는지에 대한 깊은 통찰을 제공하는, 살아있는 OS 교과서였다.

* **추상화의 위대함**: `|`나 `>` 같은 간단한 기호 뒤에 `fork`, `pipe`, `dup2`, `execve`와 같은 복잡한 시스템 콜들의 오케스트라가 숨어있음을 깨달으며, 잘 설계된 추상화의 힘을 체감했다.
* **프로세스 관리의 정수**: 부모와 자식 프로세스의 관계, 파일 디스크립터의 상속, 프로세스의 라이프사이클을 직접 관리하며 운영체제의 핵심 역할인 프로세스 관리를 피부로 이해하게 되었다.
* **설계의 중요성**: 어휘 분석기, 구문 분석기, 실행기를 각각 독립된 모듈로 설계하고, 이들을 연결하는 명확한 자료구조(AST)를 정의하는 과정은, 복잡한 시스템을 구축하기 위해선 견고한 아키텍처 설계가 선행되어야 함을 가르쳐주었다.

결론적으로 `Minishell`은 텍스트 한 줄이 어떻게 운영체제와 상호작용하여 강력한 연산의 파이프라인으로 거듭나는지를 직접 증명해 보이는, 개발자로서의 시야를 근본적으로 확장시킨 프로젝트였다.