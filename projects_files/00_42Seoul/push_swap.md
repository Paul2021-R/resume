# 🔄 push_swap: 스택과 알고리즘의 왈츠, 최적의 해를 찾아서

C언어의 기본기를 다지고, 파일 입출력의 세계를 경험한 나에게 `push_swap`은 '알고리즘'이라는 거대한 산맥의 입구를 보여준 프로젝트였어. "두 개의 스택(stack)과 정해진 명령어만으로, 흩어진 숫자들을 가장 효율적으로 정렬하라." 이 한 문장의 미션은 그야말로 두뇌 풀가동을 요구하는 거대한 퍼즐이었지. 🧩

단순히 '정렬'하는 것을 넘어, '가장 적은 횟수로'라는 제약 조건은 나를 깊은 고민의 늪으로 빠뜨렸어. 이건 그냥 코딩이 아니었어. 최적의 수를 찾는 전략 게임이었지.

## 🎲 게임의 규칙: 두 개의 스택과 11개의 마법 주문

`push_swap`의 세계는 아주 간단한 규칙으로 이루어져 있어.

1.  **두 개의 스택**: 모든 숫자가 담겨 시작하는 `stack_a`와 텅 비어있는 조수 `stack_b`.
2.  **11개의 명령어**:
    -   `s` (swap): `sa`, `sb`, `ss` - 스택의 맨 위 두 요소를 맞바꾼다.
    -   `p` (push): `pa`, `pb` - 한 스택의 맨 위 요소를 다른 스택으로 옮긴다.
    -   `r` (rotate): `ra`, `rb`, `rr` - 모든 요소를 한 칸씩 위로 올린다 (맨 위는 맨 아래로).
    -   `rr` (reverse rotate): `rra`, `rrb`, `rrr` - 모든 요소를 한 칸씩 아래로 내린다 (맨 아래는 맨 위로).

이 제한된 도구만을 사용해서 `stack_a`를 오름차순으로 정렬하고, 그 과정을 가장 짧은 명령어 조합으로 출력해 내는 것이 이 게임의 목표였어.

## 💡 최강의 무기: LIS (최장 증가 부분 수열)

"어떻게 하면 가장 적게 움직일 수 있을까?" 이 질문에 대한 해답은 바로 **LIS (Longest Increasing Subsequence)** 알고리즘에 있었어.

> **"전부 다 옮길 필요가 있나? 어차피 순서가 어느 정도 맞는 녀석들은 그대로 두고, 흐름을 방해하는 녀석들만 잠시 치워두면 되지 않을까?"**

이 발상이 바로 내 `push_swap` 전략의 핵심이었지.

1.  **LIS 찾기**: 먼저, `stack_a`에 있는 숫자들 중에서 '최장 증가 부분 수열'을 찾아내. 예를 들어 `[3, 1, 5, 2, 6, 4]`가 있다면, LIS는 `[1, 2, 4]` 또는 `[3, 5, 6]`이 될 수 있어. 이들은 이미 상대적인 오름차순을 유지하고 있는 '핵심 멤버'들이야.
2.  **'문제아'들 격리하기**: LIS에 속하지 않는 나머지 숫자들(위 예시에서 `[3, 5, 6]`을 LIS로 잡았다면 `[1, 2, 4]`)을 모두 `stack_b`로 보내버려 (`pb` 명령어 사용).
3.  **정예 멤버만 남은 A**: 이제 `stack_a`에는 LIS 멤버들만 남아있으니, 정렬하기가 훨씬 수월해졌지!

이 LIS를 찾는 과정에서도 `O(n log n)`의 시간 복잡도를 가진 이분 탐색(lower_bound) 기반의 알고리즘을 구현하면서, 효율적인 코드에 대한 고민을 깊게 할 수 있었어.

## 💃 화려한 피날레: B 스택의 귀환과 최적의 자리 찾기

이제 `stack_a`에는 핵심 멤버들이, `stack_b`에는 잠시 격리됐던 멤버들이 있어. 이제부터가 진짜 쇼타임이었지. `stack_b`의 멤버들을 하나씩 `stack_a`의 제자리로 돌려보내야 해.

-   **최소 비용 계산**: `stack_b`의 맨 위에 있는 숫자를 `stack_a`의 올바른 위치에 끼워 넣으려면 몇 번의 `rotate`가 필요할까? 이때 `stack_a`와 `stack_b`를 각각 몇 번 돌려야 하는지(`ra`/`rra`와 `rb`/`rrb`의 횟수) 계산했어.
-   **최고의 선택**: `stack_b`에 있는 모든 숫자에 대해 이 '비용'을 계산하고, 가장 적은 명령어로 옮길 수 있는 '최고의 선택'을 찾아냈지. (`check_best_choice.c` 파일이 바로 이 역할을 했어!)
-   **동시 회전(rr, rrr) 최적화**: 만약 `stack_a`와 `stack_b`를 둘 다 위로(`ra`, `rb`) 또는 둘 다 아래로(`rra`, `rrb`) 돌려야 한다면? `rr`이나 `rrr` 명령어로 한 번에 처리해서 명령어 수를 아꼈어. 이 작은 디테일이 모여 큰 차이를 만들었지.

이 과정을 `stack_b`가 텅 빌 때까지 반복하고, 마지막으로 `stack_a`의 맨 위에 가장 작은 숫자가 오도록 살짝 돌려주면(`ra` 또는 `rra`) 정렬 끝!

## 🤔 성찰 및 배운 점 (Reflection & Lessons Learned)

`push_swap`은 나에게 알고리즘적 사고의 중요성을 일깨워준 프로젝트야.

-   **문제 분해 능력**: '최소 횟수로 정렬'이라는 막막한 문제를 'LIS 찾기', 'B로 보내기', '최소 비용으로 다시 가져오기'라는 단계적인 문제로 쪼개어 해결하는 법을 배웠어.
-   **자료구조와 알고리즘**: 연결 리스트로 스택을 구현하고, LIS라는 고전적인 알고리즘을 학습하며 컴퓨터 과학의 깊이를 느낄 수 있었지.
-   **최적화 마인드**: "작동한다"에서 그치지 않고, "더 효율적으로 작동한다"를 고민하게 된 첫 번째 프로젝트였어. 모든 명령어 하나하나의 비용을 생각하며 코드를 짜는 경험은 정말 특별했지.
-   **예외 처리의 중요성**: 3개, 5개 등 적은 개수의 인풋에 대해서는 LIS 알고리즘보다 더 간단하고 효율적인 하드코딩 방식이 필요하다는 걸 깨닫고 `exception_lis.c` 같은 예외 처리 로직을 구현하며 완성도를 높였어.

`push_swap`은 단순히 스택을 정렬하는 과제가 아니었어. 논리적 사고와 문제 해결 능력, 그리고 효율성을 향한 집념을 기를 수 있었던 값진 훈련이었지. 이 프로젝트를 통해 나는 '코더'에서 '알고리즘을 고민하는 개발자'로 한 걸음 더 성장할 수 있었다고 생각해. 💪
