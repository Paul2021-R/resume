# ⚙️ ft_containers: C++ STL의 심장부를 파헤치다!

안녕하세요! 오늘은 42서울 과정의 C++ 파트 끝판왕, `ft_containers` 프로젝트에 대한 제 영혼을 갈아 넣었던(?) 경험을 공유해볼까 해요. 이 과제의 목표는 C++ 표준 라이브러리(STL)의 핵심 컨테이너인 `vector`, `map`, `stack`, `set`을 C++98 표준에 맞춰서! 직접! 구현하는 것이랍니다. (네, 맞아요. `auto`도, `range-based for`도, 스마트 포인터도 없이 오직 순수한 C++98의 힘으로만요! 🤯)

이 프로젝트는 제게 C++ 템플릿의 세계가 얼마나 깊고 오묘한지, 그리고 우리가 무심코 사용하던 STL 컨테이너들이 얼마나 정교한 설계 위에 서 있는지를 깨닫게 해준 값진 경험이었어요.

## 📜 과제 요약: STL, 너 자신을 알라!

`ft_containers`는 단순히 `std::vector`를 `ft::vector`로 이름만 바꿔서 구현하는 과제가 아니에요. 실제 STL 컨테이너와 동일하게 동작하도록, 그 내부의 자료구조와 메모리 관리 방식, 그리고 이 모든 것을 떠받치는 C++의 핵심 개념들을 밑바닥부터 쌓아 올려야 했죠.

-   **`ft::vector`:** 동적 배열의 구현! `size`와 `capacity`의 개념을 이해하고, 배열이 꽉 찼을 때 더 큰 공간을 할당받아 이사 가는(reallocation) 과정을 직접 관리해야 했어요.
-   **`ft::stack`:** 컨테이너 어댑터(Container Adapter)의 정석! 이미 구현한 `vector`를 내부 컨테이너로 활용해서 LIFO(Last-In, First-Out) 정책을 따르는 스택을 만드는, 비교적 간단하지만 중요한 개념이었죠.
-   **`ft::map` & `ft::set`:** 이 과제의 '진짜' 보스. 이 둘을 구현하기 위해선 **레드-블랙 트리(Red-Black Tree)**라는 자가 균형 이진 탐색 트리(Self-balancing Binary Search Tree)를 직접 구현해야 했답니다. `rbtree.hpp` 파일이 바로 그 고통과 환희의 증거물이죠. 덕분에 삽입, 삭제, 검색이 모두 평균적으로 O(log n)의 시간 복잡도를 갖는 효율적인 컨테이너를 만들 수 있었어요. (저의 `ft_container.drawio` 파일에 그렸던 수많은 트리 그림들이 눈에 선하네요...🌳)

## 🧠 핵심 학습 포인트: C++ 템플릿과 SFINAE의 향연

이 과제를 해결하면서 저는 C++의 여러 고급 개념들과 정면으로 마주해야 했어요.

1.  **템플릿 메타프로그래밍 (Template Metaprogramming):** 모든 컨테이너와 유틸리티는 어떤 자료형이든 담을 수 있도록 템플릿으로 작성되었어요. 이건 그냥 `template <typename T>`를 쓰는 수준을 넘어, 템플릿이 컴파일 타임에 어떻게 동작하는지에 대한 깊은 이해를 요구했죠.
2.  **이터레이터 (Iterators):** 컨테이너의 내부를 순회하는 '포인터 같은' 객체, 이터레이터를 직접 구현하는 것은 이 과제의 핵심 중 하나였어요. `iterator_traits`를 통해 이터레이터의 속성(종류, 값 타입 등)을 정의하고, `reverse_iterator`를 구현하며 STL의 유연한 설계 사상을 엿볼 수 있었답니다.
3.  **SFINAE (Substitution Failure Is Not An Error):** "치환 실패는 오류가 아니다"라는, 이름부터 범상치 않은 이 C++의 규칙은 정말 제 머리를 하얗게 만들었죠. `enable_if`를 사용해서 특정 조건이 만족될 때만 특정 템플릿 함수나 생성자가 존재하도록 만드는 기술인데, 예를 들어 `vector`의 생성자 `vector(size_type n, ...)`와 `vector(InputIterator first, ...)`가 정수 타입에 대해 모호해지는 문제를 해결하는 데 아주 유용하게 사용했어요. `study` 폴더에 남겨진 테스트 코드들이 바로 이 SFINAE와 씨름했던 흔적들이랍니다.
4.  **Allocator:** `std::allocator`를 통해 컨테이너의 메모리 할당과 해제를 직접 제어하면서, C++의 RAII(Resource Acquisition Is Initialization) 원칙과 메모리 관리의 중요성을 다시 한번 깨달았어요.

## ✨ 느낀 점

`ft_containers`는 단순히 C++ 문법을 아는 것을 넘어, C++의 철학을 이해하게 만들어준 과제였어요. `tester` 폴더에 가득한 테스트 코드와 `deepthought` 폴더의 `diff` 파일들이 보여주듯, 수많은 테스트와 디버깅을 거치며 실제 `std` 컨테이너와 제 `ft` 컨테이너의 동작을 1:1로 비교하는 과정은 정말이지... 값진 경험이었습니다. 이 프로젝트를 끝내고 나니, 이제는 STL 코드를 봐도 "외계어"가 아닌 "잘 짜인 설계도"로 보이기 시작했답니다. (물론 여전히 어렵지만요! 😂) C++ 개발자로서 한 단계 성장하고 싶다면, 이만한 과제는 없다고 생각해요!
