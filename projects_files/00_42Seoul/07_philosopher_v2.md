## 🤔 philosopher : 동시성(Concurrency)의 두 가지 난제, 교착상태와 경쟁상태

`so_long`이 프로그램의 상태를 시각적 세계로 확장하는 경험이었다면, `philosopher`는 눈에 보이지 않는 시간의 축 위에서 여러 실행 흐름이 얽힐 때 발생하는 문제, 즉 **동시성(Concurrency)**의 심연을 들여다보는 과제다. 이 프로젝트는 컴퓨터 과학의 고전적인 '식사하는 철학자들' 문제를 통해, 현대 멀티코어 환경에서 동작하는 모든 소프트웨어가 필연적으로 마주하는 두 가지 핵심 난제를 우리 앞에 제시한다: **자원 경쟁(Resource Competition)**과 **실행 흐름의 동기화(Synchronization)**.

이 과제는 단순히 스레드와 뮤텍스 API를 사용하는 법을 배우는 것을 넘어선다. 왜 동기화가 필요한지, 잘못된 동기화가 어떻게 시스템 전체를 마비시키는지, 그리고 교착상태와 경쟁상태라는 유령 같은 버그를 피하기 위해 얼마나 정교한 논리적 설계가 필요한지를 직접 증명하고 체감하는, 시스템 프로그래밍의 통과 의례와도 같은 과정이었다.

### 📜 문제의 본질: 한정된 자원과 비결정적 실행 순서

'식사하는 철학자들' 문제는 동시성 시스템의 축소판이다.

* **철학자 (Philosopher)**: 스레드(Thread) 또는 프로세스(Process)와 같은 독립적인 실행 단위를 상징한다.
* **포크 (Fork)**: 데이터베이스 커넥션, 파일 핸들러, 하드웨어 장치 등 동시에 접근할 수 없는 **공유 자원(Shared Resource)**을 상징한다.
* **식사 (Eating)**: 공유 자원을 점유하여 작업을 수행하는 **임계 영역(Critical Section)**을 의미한다.

이 모델에서 발생하는 근본적인 문제는, 각 스레드의 실행 순서와 시점을 운영체제의 스케줄러가 결정하기 때문에 **비결정적(Non-deterministic)**이라는 사실에서 출발한다. 이 비결정성이 두 가지 치명적인 버그를 낳는다.

1.  **교착 상태 (Deadlock)**: 둘 이상의 스레드가 서로가 점유한 자원을 기다리며 더 이상 진행하지 못하는 상태. 이는 다음의 **4가지 조건(Coffman Conditions)**이 모두 충족될 때 발생한다.
    * **상호 배제 (Mutual Exclusion)**: 자원은 한 번에 하나의 스레드만 사용할 수 있다.
    * **점유 대기 (Hold and Wait)**: 자원을 하나 점유한 상태에서 다른 자원을 추가로 요청하며 대기한다.
    * **비선점 (No Preemption)**: 다른 스레드가 점유한 자원을 강제로 빼앗을 수 없다.
    * **환형 대기 (Circular Wait)**: 각 스레드가 다음 스레드가 점유한 자원을 요구하는 원형의 대기열이 형성된다.
2.  **경쟁 상태 (Race Condition)**: 여러 스레드가 동시에 공유 자원에 접근하여 수정할 때, 실행 순서에 따라 결과가 의도와 다르게 나오는 상황. `printf`와 같은 단순한 출력 함수조차도 내부적으로 여러 단계로 동작하기에, 동기화 없이는 메시지가 뒤섞여 깨지는 경쟁 상태를 유발한다.
3.  **기아 상태 (Starvation)**: 특정 스레드가 자원을 할당받을 기회를 영원히 얻지 못하는 상태. 교착 상태는 모든 스레드가 멈추지만, 기아 상태는 다른 스레드들은 정상 동작하는 와중에 일부 스레드만 고립된다는 차이가 있다.

### 🛠️ Part 1: 스레드와 뮤텍스를 이용한 동기화 (Mandatory)

이 파트의 목표는 공유 메모리 모델의 동시성 단위인 **스레드(Thread)**와, 임계 영역을 보호하기 위한 가장 기본적인 동기화 도구인 **뮤텍스(Mutex)**를 사용하여 문제를 해결하는 것이다.

* **솔루션의 핵심**: 교착 상태를 유발하는 4가지 조건 중 하나를 깨뜨리는 것이다. 모든 철학자가 '왼쪽 포크 -> 오른쪽 포크' 순서로 자원을 요청하면 **환형 대기(Circular Wait)** 조건이 성립하기 쉽다. 이를 해결하기 위해 **짝수 번호 철학자는 왼쪽부터, 홀수 번호 철학자는 오른쪽부터** 포크를 집도록 순서를 비대칭적으로 설계했다. 이 간단한 규칙의 변화가 자원 요청의 의존성 고리를 끊어 환형 대기를 원천적으로 방지한다.
* **모니터링 스레드의 필요성**: 각 철학자 스레드가 자신의 사망 여부를 스스로 판단하게 할 경우, 다른 스레드가 점유한 뮤텍스로 인해 블로킹되어 자신의 상태를 제때 확인하지 못할 수 있다. 따라서 철학자들의 상태를 감시하고 시뮬레이션을 종료하는 역할은, 철학자들이 사용하는 뮤텍스로부터 자유로운 별도의 **모니터링 스레드(Watchdog)**가 수행해야만 안정적인 감시가 가능하다.

### 🚀 Part 2: 프로세스와 세마포어를 이용한 IPC (Bonus)

보너스 파트는 독립적인 메모리 공간을 가진 **프로세스(Process)**를 `fork()`로 생성하고, **프로세스 간 통신(IPC, Inter-Process Communication)**을 통해 동기화 문제를 해결할 것을 요구한다.

* **프로세스 모델의 차이**: 스레드와 달리 프로세스는 메모리를 공유하지 않으므로, 뮤텍스처럼 메모리 주소를 공유하는 방식으로는 동기화할 수 없다. 따라서 커널 수준에서 관리되는 IPC 객체를 사용해야 한다.
* **세마포어 (Semaphore)**: 뮤텍스가 단 하나의 실행 흐름만 허용하는 잠금(lock)이라면, 세마포어는 **정해진 개수(N)만큼의 실행 흐름을 동시에 허용**하는 계수기(counter)이다. 이 문제에서는 모든 포크를 하나의 자원 풀로 보고, 포크의 총 개수를 카운트로 하는 세마포어 하나로 관리할 수 있다. 철학자는 `sem_wait`으로 포크 하나를 획득(카운트 감소)하고, `sem_post`로 반납(카운트 증가)한다. 이는 N개의 자원을 관리하는 데 있어 N개의 뮤텍스를 사용하는 것보다 훨씬 간결하고 직관적인 모델을 제공한다.
* **프로세스 모니터링**: 부모 프로세스가 `waitpid`를 통해 자식 프로세스들의 종료 상태를 감시한다. 한 명의 철학자라도 사망(비정상 종료)하면, 부모 프로세스는 다른 모든 자식 프로세스들에게 `kill` 시그널을 보내 전체 시뮬레이션을 정리하는 역할을 수행한다.

### ✨ 성찰 및 배운 점

`philosopher`는 동시성 버그가 왜 재현하기 어렵고 디버깅하기 힘든지, 그리고 왜 처음부터 신중한 설계가 중요한지를 가르쳐주었다.

* **동시성 설계의 중요성**: 동시성 문제는 나중에 수정하는 것이 거의 불가능에 가깝다. 시스템 설계 단계부터 어떤 자원이 공유되고, 어떤 임계 영역이 존재하며, 어떤 동기화 전략을 사용할지 명확히 정의해야 함을 깨달았다.
* **동기화 도구의 이해**: 뮤텍스는 **상호 배제**가 필요할 때, 세마포어는 **자원 풀링(Pooling)**이나 복잡한 실행 순서 제어가 필요할 때 사용하는 등, 각 동기화 도구의 본질적인 목적과 사용 사례를 구분하는 능력을 기를 수 있었다.
* **이론과 현실의 연결**: 교착 상태의 4가지 조건과 같은 이론적 모델이 실제 코드에서 어떻게 발현되고, 그 이론에 기반하여 어떻게 문제를 해결할 수 있는지 직접 증명해 보았다. 이 경험은 데이터베이스의 트랜잭션 처리, 웹 서버의 스레드 풀 관리 등 현실 세계의 복잡한 동시성 시스템을 이해하는 단단한 기반이 되어주었다.