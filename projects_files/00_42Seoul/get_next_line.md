# 📄 Get_Next_Line: 정적 변수와 파일 디스크립터의 늪에서 한 줄기 빛을 찾다

`libft`로 C언어의 근육을 키웠다고 생각했을 때, `get_next_line`(이하 GNL)이라는 새로운 산이 나타났어. "파일에서 한 줄씩 읽어오는 함수를 만들라"는 이 과제, 겉보기엔 간단해 보였지만... 오, 신이시여. 이건 완전히 다른 차원의 이야기였지. 😅 C언어의 저수준(low-level) 파일 입출력과 처음으로 마주하며, `static`이라는 키워드의 진정한 힘을 깨닫게 된 여정이었어.

## 🧠 핵심 개념 정복하기 (Conquering Core Concepts)

GNL을 이해하기 위해선 몇 가지 핵심 개념을 반드시 넘어야 했어.

### 1. 파일 디스크립터(File Descriptor)와의 첫 만남

지금까지 `printf`로 화면에 글자를 찍어내는 게 전부였다면, GNL은 파일과의 직접적인 소통을 요구했어. 이때 등장하는 것이 바로 **파일 디스크립터(File Descriptor, FD)**! 운영체제가 파일이나 소켓 같은 입출력 리소스에 접근하기 위해 붙여주는 번호표 같은 거야.

-   `0`: 표준 입력 (Standard Input, 키보드 입력)
-   `1`: 표준 출력 (Standard Output, 모니터 출력)
-   `2`: 표준 에러 (Standard Error, 에러 메시지 출력)

`open()` 함수로 파일을 열면 3번부터 차례대로 번호표가 발급되는데, GNL은 바로 이 번호표를 가지고 파일을 읽어오는 함수였던 거지. `main` 함수에서 `open()`으로 파일을 열어보기도 하고, FD 자리에 `0`을 넣어 키보드 입력을 받아보기도 하면서 파일 입출력의 기본 원리를 몸으로 체득할 수 있었어.

### 2. `read()`와 `BUFFER_SIZE`의 밀당

GNL에서 허용된 유일한 파일 읽기 함수는 `read`였어. 이 함수는 정해진 `BUFFER_SIZE`만큼만 파일을 읽어와. 여기서 문제가 시작되지.

-   `BUFFER_SIZE`가 내가 읽으려는 한 줄보다 작으면? -> 여러 번 `read`해야 해.
-   `BUFFER_SIZE`가 내가 읽으려는 한 줄보다 크면? -> 한 줄을 읽고도 데이터가 남네?

이 '남는 데이터'를 어떻게 처리하느냐가 GNL의 핵심이었어. 이번에 읽고 남은 데이터를 어딘가에 잘 보관해 뒀다가, 다음에 GNL이 호출될 때 먼저 사용해야 했거든.

### 3. 마법의 키워드, `static`

바로 여기서 `static` 변수가 구원투수로 등판해! ✨

```c
char *get_next_line(int fd)
{
    static char *backup;
    // ...
}
```

함수 내에 선언된 일반적인 지역 변수는 함수가 끝나면 사라지지만, `static` 키워드가 붙은 변수는 프로그램이 끝날 때까지 그 값을 계속 기억해. 즉, GNL 함수가 여러 번 호출되더라도 `backup` 변수는 이전에 읽고 남겨둔 데이터를 그대로 간직하고 있는 거지!

이 `static` 변수 `backup`에 `read`로 읽어온 내용을 계속 이어 붙이고, 개행 문자(`\n`)를 찾으면 그 앞까지를 반환한 뒤, `backup`에는 개행 문자 뒤의 나머지 내용을 저장해두는 것. 이것이 바로 GNL의 심장과도 같은 로직이었어.

## 🛠️ 나의 GNL 구현기 (My GNL Implementation Journey)

로직은 간단해 보였지만, 구현은 험난했지.

1.  **읽고 붙이기**: `read` 함수를 반복문으로 돌면서 `backup`에 데이터가 없으면 새로 할당하고, 있으면 기존 내용 뒤에 이어 붙였어 (`ft_strjoin`이 여기서 빛을 발했지!). 
2.  **개행 찾기**: `backup`에 개행 문자(`\n`)가 있는지 계속 확인했어.
3.  **자르고 반환하기**: 개행을 찾으면, 개행까지의 내용을 새로운 문자열로 복사해서 반환(`ret`)했어.
4.  **남은 내용 저장하기**: 그리고 `static` 변수인 `backup`은 개행 문자 뒷부분의 내용으로 업데이트해서 다음 호출을 대비했지. 이 과정에서 메모리 누수(leak)를 막기 위해 수없이 `free`와 `malloc`을 반복하며 디버깅했던 기억이 나. (정말이지, 머리카락이 숭숭 빠지는 기분이었달까... 😇)

## ✨ 보너스: 여러 파일을 동시에! (Bonus: Multiple Files at Once!)

필수 파트의 GNL은 `static` 변수 하나만 쓰기 때문에 한 번에 하나의 파일밖에 못 읽는다는 한계가 있었어. 하지만 보너스 파트에서는 여러 파일을 동시에 열고, 번갈아 가며 GNL을 호출해도 각 파일의 읽기 상태를 유지해야 했지.

이걸 어떻게 해결했을까? 바로 **연결 리스트(Linked List)** 또는 **배열**을 사용하는 거야!

-   **배열 방식**: `static char *backup[OPEN_MAX];` 처럼 파일 디스크립터의 최대 개수만큼 배열을 선언하고, `backup[fd]`처럼 각 파일 디스크립터 번호에 해당하는 인덱스에 남은 데이터를 저장하는 방식이야. 간단하지만 메모리 낭비가 있을 수 있지.
-   **연결 리스트 방식**: 각 노드(node)에 파일 디스크립터 번호(`fd`)와 해당 파일의 `backup` 데이터를 저장하는 거지. GNL이 호출되면, 연결 리스트를 순회해서 현재 `fd`에 맞는 노드를 찾아 작업을 수행하는 거야. 이게 좀 더 유연하고 효율적인 방법이었어!

## 🤔 성찰 및 배운 점 (Reflection & Lessons Learned)

GNL은 나에게 C언어의 더 깊은 세계를 보여줬어.

-   **저수준 I/O**: 파일 디스크립터와 `read` 함수를 통해 컴퓨터가 파일을 어떻게 다루는지 근본적인 수준에서 이해하게 됐어.
-   **`static`의 재발견**: `static`이 단순히 '정적'이라는 의미를 넘어, 함수의 상태를 기억하는 강력한 도구임을 깨달았지.
-   **메모리 관리의 중요성**: 문자열을 자르고 붙이는 과정에서 메모리를 동적으로 할당하고 해제하는 훈련을 통해 메모리 누수에 대한 경각심을 기를 수 있었어.

`get_next_line`은 단순히 파일을 읽는 함수가 아니었어. 버퍼링의 개념, 상태 관리의 중요성, 그리고 C언어의 날 것 그대로의 메모리 제어를 온몸으로 부딪히며 배운 값진 경험이었지. 이 프로젝트를 통해 얻은 자신감은 이후의 어떤 과제도 두렵지 않게 만들어 준 든든한 밑거름이 되었어. 💪

```