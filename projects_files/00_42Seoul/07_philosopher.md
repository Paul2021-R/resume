# 🤔 철학자들의 만찬: 교착상태와 경쟁상태를 맛보다!

안녕하세요! 오늘은 42서울 과정 중에서도 악명 높기로 소문난 `philosopher` 과제에 대한 이야기를 풀어볼까 해요. '배고픈 철학자들'이라는 고전적인 컴퓨터 과학 문제를 해결하는 건데, 단순히 코드를 짜는 걸 넘어서 동시성(concurrency) 프로그래밍의 깊은 곳까지 탐험해야 했답니다. (정말이지... 철학자들이 밥 한번 먹기 참 힘들더라고요. 🤣)

이 과제를 통해 저는 **스레드(thread)**와 **프로세스(process)**, 그리고 **뮤텍스(mutex)**와 **세마포어(semaphore)** 같은 동기화 메커니즘을 온몸으로 부딪히며 배울 수 있었어요.

## 📜 과제 요약: 굶어 죽거나, 영원히 생각하거나

원탁에 여러 명의 철학자가 앉아 있어요. 각 철학자의 양옆에는 포크가 하나씩 놓여있죠. 철학자들은 **생각하기 -> 밥 먹기 -> 잠자기**를 무한히 반복해요. 그런데 문제가 있어요. 밥을 먹으려면 양손에 포크를 모두 쥐어야 한다는 것!

![Dining Philosophers Problem](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/300px-An_illustration_of_the_dining_philosophers_problem.png)
*(이미지 출처: Wikipedia)*

여기서 잘못된 로직을 짜면...
1.  **교착 상태 (Deadlock):** 모든 철학자가 왼쪽 포크만 집어 들고 오른쪽 포크가 내려오기만을 영원히 기다리는 상태. 결국 아무도 밥을 못 먹고 다 같이 굶어 죽게 되죠.
2.  **경쟁 상태 (Race Condition):** 여러 스레드가 동시에 공유 자원(예: 포크 상태, 출력)에 접근하려다 보니 데이터가 꼬이거나, 누군가 죽었는데 그 사실이 제대로 공유되지 않는 문제가 발생해요.

저의 임무는 이 두 가지 문제를 해결하고 철학자들이 무사히 식사를 계속하게 만드는 것이었답니다.

## 🛠️ Part 1: 스레드와 뮤텍스로 문제 해결하기 (Mandatory)

첫 번째 도전은 `pthread` 라이브러리를 이용해 각 철학자를 스레드로 만들고, `mutex`를 사용해 공유 자원을 보호하는 것이었어요.

-   **스레드 (Thread):** 각 철학자는 하나의 스레드로 동작해요. `pthread_create`로 철학자들을 세상에 내보내죠.
-   **뮤텍스 (Mutex):** '포크'와 '콘솔 출력'이라는 공유 자원을 보호하기 위한 잠금장치예요. 한 스레드가 포크를 사용하거나 `printf`로 상태를 출력할 땐, 다른 스레드가 끼어들지 못하도록 `pthread_mutex_lock`으로 문을 걸어 잠가야 했죠.
-   **교착 상태 해결:** 모든 철학자가 똑같은 순서로 포크를 집으면 교착 상태에 빠지기 쉬워요. 그래서 저는 짝수 번째 철학자는 왼쪽 포크부터, 홀수 번째 철학자는 오른쪽 포크부터 집도록 순서를 다르게 해서 이 문제를 해결했답니다. (이 전략을 짜느라 `philosopher`라는 이름의 다이어그램 파일에 로직을 열심히 그렸던 기억이 나네요. 😅)
-   **모니터링 스레드:** 철학자가 굶어 죽었는지 감시하는 별도의 '감시자' 스레드를 만들었어요. 만약 철학자 스레드 안에서 자신의 죽음을 체크하면, 다른 철학자가 일으킨 뮤텍스 락 때문에 정작 죽었는지 확인할 기회조차 얻지 못하고 멈춰버릴 수 있거든요.

## 🚀 Part 2: 프로세스와 세마포어로 레벨 업! (Bonus)

보너스 파트에서는 스레드 대신 `fork()`를 사용해 철학자들을 별도의 프로세스로 만들고, `semaphore`로 동기화를 구현해야 했어요.

-   **프로세스 (Process):** `fork()`를 호출하면 부모 프로세스와 똑같은 자식 프로세스가 복제돼요. 각 철학자가 독립적인 프로세스로 실행되는 거죠.
-   **세마포어 (Semaphore):** 뮤텍스가 '화장실 열쇠'처럼 하나뿐인 자원을 관리한다면, 세마포어는 '주차장 자리'처럼 여러 개 있는 자원을 관리하는 데 더 효과적이에요. 포크의 개수만큼 세마포어 값을 설정해두고, 철학자가 `sem_wait`으로 포크를 가져가고 `sem_post`로 반납하는 식으로 훨씬 직관적으로 구현할 수 있었어요.
-   **모니터링:** 부모 프로세스가 감시자 역할을 해요. `waitpid` 함수를 통해 자식 프로세스(철학자) 중 하나라도 비정상적으로 종료(죽음)되면, 다른 모든 자식 프로세스에게 `kill` 시그널을 보내 만찬을 종료시키는 방식으로 구현했답니다.

## ✨ 느낀 점

`philosopher`는 제게 동시성 프로그래밍의 무서움과 중요성을 동시에 알려준 과제였어요. 눈에 보이지 않는 순서 꼬임이 어떻게 프로그램을 망가뜨리는지, 그리고 그것을 막기 위해 왜 뮤텍스와 세마포어 같은 도구가 필요한지를 뼈저리게 느꼈죠. `study` 폴더에 `thread_*.c`, `sem_*.c` 같은 테스트 코드를 잔뜩 만들며 공부했던 시간들이 주마등처럼 스쳐 지나가네요. 이 과제를 통과하고 나니, 이제는 멀티 스레드 환경의 코드를 봐도 조금은 덜 두려운 마음으로 분석할 수 있게 된 것 같아요! (물론 여전히 어렵지만요! 😉)
