# 📢 Minitalk: 프로세스끼리 나누는 비밀스러운 귓속말, 시그널(Signal)의 재발견

`so_long`으로 그래픽의 맛을 살짝 봤다면, `Minitalk`은 다시 시스템의 깊은 곳으로 나를 이끌었어. 이번 과제의 컨셉은 정말이지 기발했지. "네트워크 없이, 오직 유닉스 시그널(Signal) 두 개(`SIGUSR1`, `SIGUSR2`)만을 사용해서 클라이언트와 서버 프로세스 간에 문자열을 전송하라!"

처음엔 정말 막막했어. 시그널은 보통 프로세스를 종료시키거나(`SIGINT`), 잠시 멈추게 하는(`SIGSTOP`) 등의 제어 용도로만 알고 있었거든. 이걸로 어떻게 '데이터'를 보낸단 말이야? 🤔 하지만 이내 깨달았지. 컴퓨터 세상의 모든 데이터는 결국 0과 1의 조합이라는 사실을!

## 💡 0과 1, 두 개의 시그널에 담긴 약속

`Minitalk`의 핵심 아이디어는 바로 이것이었어.

-   **`SIGUSR1`은 숫자 0을 의미한다.**
-   **`SIGUSR2`는 숫자 1을 의미한다.**

이 간단한 약속 하나로, 우리는 모든 문자를 서버에 전송할 수 있게 돼. 예를 들어, 문자 'A'는 아스키코드로 65이고, 이진수로는 `01000001`이잖아? 그럼 클라이언트는 서버에게 이 순서대로 시그널을 보내는 거야.

`SIGUSR1` → `SIGUSR2` → `SIGUSR1` → `SIGUSR1` → `SIGUSR1` → `SIGUSR1` → `SIGUSR1` → `SIGUSR2`

서버는 이 8개의 신호를 차례대로 받아서 다시 `01000001`이라는 이진수로 조립하고, 그걸 문자 'A'로 해석해서 화면에 출력하는 거지. 정말 기가 막히지 않아? 😉

## 🤝 클라이언트와 서버의 완벽한 호흡 (feat. PID와 동기화)

이 마법 같은 통신을 구현하기 위해 몇 가지 중요한 개념들을 정복해야 했어.

### 1. 서버의 자기소개: `getpid()`

-   서버 프로그램이 실행되면, 가장 먼저 자신의 **PID(Process ID)**를 화면에 출력해. 이건 마치 "나 여기 있으니, 나한테 편지 보낼 사람들은 이 주소로 보내!"라고 외치는 것과 같아.
-   클라이언트는 이 PID를 첫 번째 인자로 받아서, `kill` 함수를 통해 정확히 해당 서버 프로세스에게 시그널을 보낼 수 있게 되지.

### 2. 비트 단위 인코딩 & 디코딩: 비트 연산의 향연

-   **클라이언트 (송신자)**:
    -   전송할 문자열의 각 문자를 가져와.
    -   **비트 마스킹(Bit Masking)**과 **시프트 연산(Shift Operation)**을 사용해서 8비트 중 최상위 비트(MSB)부터 하나씩 떼어내. `(character >> i) & 1` 같은 코드로 특정 위치의 비트가 0인지 1인지 확인하는 거지.
    -   결과가 0이면 `kill(server_pid, SIGUSR1)`, 1이면 `kill(server_pid, SIGUSR2)`를 호출해서 서버에 신호를 보내.

-   **서버 (수신자)**:
    -   `sigaction` 함수로 `SIGUSR1`과 `SIGUSR2` 신호를 받았을 때 실행될 핸들러 함수를 미리 등록해둬.
    -   신호가 들어오면, 핸들러 함수가 호출돼. `SIGUSR1`이면 0, `SIGUSR2`이면 1을 임시 저장 공간(char 변수)에 누적시켜.
    -   **비트 시프트 연산**을 통해 8개의 비트를 차곡차곡 쌓아 하나의 문자를 완성해. `char_byte = (char_byte << 1) | bit;` 이 코드 한 줄에 통신의 핵심이 담겨있지!
    -   8개의 비트가 모두 모이면, 완성된 문자를 `write` 함수로 출력!

### 3. "보냈니?" "응, 받았어!": `pause()`와 `usleep()`을 이용한 동기화

-   만약 클라이언트가 비트를 미친 듯이 연속으로 보내면 어떻게 될까? 서버가 미처 처리하지 못한 시그널은 유실될 수 있어.
-   그래서 **동기화(Synchronization)**가 필수적이야.
    -   클라이언트는 비트 하나를 보내고 `pause()` 함수로 잠시 멈춰.
    -   서버는 비트 하나를 성공적으로 받아서 처리한 뒤, `kill(client_pid, SIGUSR1)`처럼 클라이언트에게 "나 잘 받았어, 다음 거 보내!"라는 응답 신호를 보내줘.
    -   응답을 받은 클라이언트는 `pause()` 상태에서 깨어나 다음 비트를 보내지.
-   이 과정을 매 비트마다 반복하면서, 데이터 유실 없이 정확한 통신이 가능해지는 거야. `usleep`을 살짝 섞어주는 건 안정성을 더하기 위한 양념 같은 거지!

## 🤔 성찰 및 배운 점 (Reflection & Lessons Learned)

`Minitalk`은 단순히 프로그램을 만드는 것을 넘어, 운영체제가 프로세스를 어떻게 관리하고 소통하는지에 대한 깊은 이해를 요구하는 프로젝트였어.

-   **시그널의 재발견**: 시그널이 단순한 인터럽트가 아니라, 창의적인 약속을 통해 데이터 통신 채널로 활용될 수 있다는 사실을 몸소 체험했어.
-   **프로세스 간 통신(IPC)**: 가장 원시적인 형태의 IPC를 구현해보면서, 동기화 문제의 중요성과 해결 방안에 대해 고민해볼 수 있었지.
-   **비트 연산의 힘**: 데이터를 가장 작은 단위인 비트 수준에서 다루는 경험은 정말 짜릿했어. C언어의 강력함을 다시 한번 느꼈달까?

클라이언트 터미널에서 보낸 문자열이 한 글자씩, 조금은 느리지만 정확하게 서버 터미널에 나타나는 것을 보았을 때의 그 감동! `Minitalk`은 나에게 보이지 않는 세상의 약속과 신호들이 어떻게 정보를 만들어내는지를 가르쳐준 소중한 경험이었어. 📡
