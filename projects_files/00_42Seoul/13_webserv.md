# webserv 프로젝트 학습 기록 🌐

`webserv`... 이 이름만 들어도 밤새 `kqueue`와 씨름하고, 생전 처음 보는 HTTP 명세서를 뒤적이며, 터미널에 찍히는 정체불명의 바이트 코드를 해석하던 기억이 생생하게 떠오르네요. 😂 이 프로젝트는 단순히 코드를 짜는 것을 넘어서, 우리가 매일 사용하는 인터넷이 어떻게 동작하는지 그 근본 원리를 파헤치는 대장정이었습니다. NGINX의 축소판을 C++98만으로 구현하는, 그야말로 '진짜' 서버 개발에 첫발을 내디딘 순간이었죠!

### ✨ 핵심 목표: 나만의 웹 서버 만들기!

이 프로젝트의 최종 목표는 명확했어요. 바로 **HTTP/1.1 프로토콜을 이해하고 직접 웹 서버를 구현하는 것!** 브라우저가 'hello'하고 말을 걸면, 우리 서버가 'world!'하고 응답해 주는, 그 단순하지만 위대한 과정을 직접 만들어보는 거였죠.

### 📚 핵심 학습 내용

정말 많은 것을 배울 수 있었지만, 가장 기억에 남는 핵심 개념들을 정리해 볼게요.

1.  **소켓 프로그래밍: 통신의 첫 단추**
    *   모든 것의 시작은 '소켓(Socket)'이었어요. `socket()`, `bind()`, `listen()`, `accept()` 함수를 차례대로 호출하며 서버의 문을 여는 방법을 배웠습니다. 이건 마치 서버의 현관문을 만들고, 주소를 부여하고, 손님을 맞이할 준비를 하는 것과 같았죠. 클라이언트의 연결 요청을 `accept()`로 받아들이는 순간, 비로소 통신이 시작되는 그 짜릿함! 잊을 수가 없네요.

2.  **I/O 멀티플렉싱과 `kqueue`: 서버 성능의 핵심**
    *   "그래서, 클라이언트가 100명, 1000명이 되면 어떡할 건데?" 이 질문에 대한 답이 바로 I/O 멀티플렉싱(Multiplexing)이었어요. 여러 개의 클라이언트 연결(I/O)을 하나의 프로세스에서 효율적으로 관리하는 기술이죠.
    *   특히 macOS와 BSD 계열의 보석 같은 존재, `kqueue`를 사용했습니다. `kqueue`는 "이 파일 디스크립터(FD)에서 읽을 데이터가 생기면 알려줘!" 하고 커널에 이벤트를 등록해두고, 실제로 이벤트가 발생할 때까지 편안하게 대기하는 방식이에요. 덕분에 무식하게 모든 클라이언트를 계속 확인하는 게 아니라, 이벤트가 발생했을 때만 똑똑하게 일하는 **비동기 이벤트 기반(Event-driven)** 서버를 만들 수 있었답니다. 이게 바로 `webserv` 성능의 심장이었죠! ❤️

3.  **설정 파일 파서(Parser): 유연함의 시작**
    *   `nginx.conf`처럼 우리 서버도 설정 파일을 통해 동작을 제어해야 했어요. `ServerConfig` 클래스를 만들어서 `server` 블록과 `location` 블록을 해석하는 파서를 직접 구현했습니다.
    *   `listen` 포트, `server_name`을 통한 가상 호스팅, `root` 디렉토리 지정, 허용할 `method` 설정 등... 사용자가 원하는 대로 서버를 커스터마이징할 수 있는 유연성을 확보하는 과정이 정말 재미있었어요. 수많은 예외 처리는 덤이었지만요. 🥲

4.  **HTTP 프로토콜: 브라우저와의 대화법**
    *   클라이언트가 보낸 생짜 `Request` 메시지를 한 줄 한 줄 파싱해서 `Method` (GET, POST, DELETE), `URI`, `HTTP Version`, 그리고 각종 `Header` 정보를 추출하는 로직을 구현했어요.
    *   반대로, 서버가 브라우저에게 보내줄 `Response` 메시지도 HTTP 규격에 맞춰 한 땀 한 땀 만들어야 했죠. `Status-Line` (e.g., `HTTP/1.1 200 OK`), `Header`, 그리고 `Body` (HTML 파일 내용 등)를 담아 보내주는 그 과정이야말로 웹 서버의 본질이었습니다.

5.  **CGI (Common Gateway Interface): 동적인 웹을 향하여**
    *   정적인 HTML 파일만 보여주는 건 심심하잖아요? 그래서 CGI라는 표준 인터페이스를 구현해서 서버가 외부 프로그램(예: Python 스크립트)을 실행하고 그 결과를 받아와 클라이언트에게 전달하는 기능을 만들었어요. `pipe()`로 프로세스 간 통로를 만들고, `fork()`와 `execve()`로 자식 프로세스를 생성해 스크립트를 실행시키는 과정은... 정말이지 시스템 프로그래밍의 정수였습니다.

### 📝 마무리

`webserv`는 제게 '보이지 않는 것을 믿게 해준' 프로젝트였어요. 브라우저 주소창에 URL을 입력하고 엔터를 치는 그 찰나의 순간, 뒷단에서 벌어지는 이토록 치열하고 정교한 통신의 세계를 직접 구축하며 정말 많이 성장할 수 있었습니다. 힘들었지만, 그만큼 가장 뿌듯했던 과제 중 하나로 기억될 거예요! 😄
