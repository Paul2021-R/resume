# 🚀 Libft: C 언어와의 첫 만남, 나만의 라이브러리 만들기

아, `libft`! 42 서울에서의 내 첫 번째 프로젝트이자, C언어의 깊은 물에 처음으로 발을 담갔던 순간이었지. C 표준 라이브러리 함수들을 직접 내 손으로 구현해야 했던 이 과제는, 마치 C언어의 심장부를 해부하는 것과 같은 경험이었어. 수많은 밤을 `man` 페이지와 함께 지새우며, 포인터와 메모리 주소와 씨름했던 기억이 아직도 생생해. (정말 쉽지 않았다고! 😂)

이 프로젝트는 단순히 함수를 베끼는 것이 아니라, 그 작동 원리를 근본부터 이해하고, 나만의 코드로 재창조하는 과정이었어. 지금부터 그 치열했던 학습의 여정을 한번 되짚어볼까 해.

## 📚 주요 학습 내용 (Key Learnings)

`libft` 프로젝트는 크게 세 부분으로 나눌 수 있어. 표준 라이브러리 함수를 구현하는 **Part 1**, 조금 더 복잡하고 유용한 함수들을 만드는 **Part 2**, 그리고 연결 리스트(Linked List)를 다루는 **Bonus** 파트까지!

### 1. 표준 라이브러리 함수 재구현 (Re-implementing Standard Library Functions)

가장 기본이 되는 파트였지. `libc`에 있는 함수들을 하나씩 정복해나가는 과정이었어.

-   **메모리 다루기 (`<string.h>` 등)**: `memset`, `memcpy`, `memmove` 같은 함수들을 만들면서 포인터와 메모리에 대한 이해가 깊어졌어. 특히 `memcpy`와 `memmove`의 차이점, 즉 메모리 오버랩(overlap) 문제를 어떻게 해결하는지를 배우면서 정말 머리를 싸맸던 기억이 나. "아니, 그냥 복사하면 되는 거 아냐?" 싶었는데, 주소 값이 겹칠 때의 그 미묘한 차이를 이해했을 때의 쾌감이란!
-   **문자열 갖고 놀기 (`<string.h>` 등)**: `strlen`, `strlcpy`, `strlcat`, `strchr`, `strncmp` 등등... C언어에서 문자열이 사실상 `char` 배열이라는 걸 뼈저리게 느꼈지. `NULL` 문자의 중요성과 버퍼 오버플로우(buffer overflow)를 방지하기 위한 `strlcpy`의 소중함을 깨달았어.
-   **문자 판별과 변환 (`<ctype.h>` 등)**: `isalpha`, `isdigit`, `isalnum` 같은 함수들은 비교적 간단했지만, 아스키코드에 대한 완벽한 이해가 필요했어.
-   **문자열을 숫자로 (`<stdlib.h>` 등)**: `atoi`를 구현하면서 온갖 예외 케이스(공백, 부호, 숫자 아닌 문자 등)를 처리하는 게 얼마나 중요한지 배웠어.

### 2. 나만의 유틸리티 함수 구현 (Implementing Additional Utility Functions)

Part 1이 '모방'의 단계였다면, Part 2는 '창조'의 단계였어. 주어진 명세에 따라 더 복잡한 기능들을 구현해야 했지.

-   **`ft_split`**: 이 녀석이 아마 최종 보스 아니었을까? 😂 문자열을 특정 구분자(delimiter) 기준으로 쪼개서 2차원 배열에 담아 반환하는 함수인데, 메모리 동적 할당의 끝판왕이었어. 할당해야 할 메모리의 크기를 정확히 계산하고, 오류가 났을 때 이미 할당된 메모리를 모두 해제(`free`)해주는 누수(leak) 방지 처리까지... 정말 많은 걸 배울 수 있었던 함수야.
-   **`ft_itoa`**: 정수를 문자열로 바꾸는 이 함수는 `INT_MIN` 같은 극단적인 케이스를 처리하는 게 핵심이었지.
-   **`ft_substr`, `ft_strjoin`, `ft_strtrim`**: 문자열을 자르고, 합치고, 특정 문자를 제거하는 이 함수들은 앞으로 다른 프로젝트들에서 정말 유용하게 쓰일 나만의 무기가 되었어.

### 3. 보너스: 연결 리스트 다루기 (Handling Linked Lists)

그리고 대망의 보너스 파트! 여기서 처음으로 '자료구조'라는 걸 접하게 됐어.

```c
typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}					t_list;
```

이 간단한 구조체로 노드(node)를 만들고, 그 노드들을 엮어서 리스트를 만들고, 새로운 노드를 추가하고(`lstnew`, `lstadd_front`, `lstadd_back`), 리스트를 순회하고(`lstiter`), 삭제하는(`lstdelone`, `lstclear`) 등... 연결 리스트의 기본적인 모든 것을 구현했어. 특히 `t_list **lst`처럼 이중 포인터를 사용해서 리스트의 시작 주소 자체를 변경해야 했던 `ft_lstadd_front` 같은 함수는 포인터에 대한 이해도를 한 단계 끌어올려 줬지.

## 🛠️ Makefile의 마법 (The Magic of Makefile)

이 프로젝트는 C 코드뿐만 아니라 `Makefile` 작성법을 제대로 배운 첫 경험이기도 해. 단순히 `gcc` 명령어를 나열하는 것을 넘어, 변수를 사용하고, `%.o: %.c` 같은 규칙을 만들고, `all`, `clean`, `fclean`, `re`, `bonus` 같은 목표(target)를 설정하면서 빌드 자동화의 편리함을 맛봤어. 이 과정을 통해 만들어진 `libft.a`라는 정적 라이브러리(static library)는 앞으로 내 모든 C 프로젝트의 든든한 기반이 되어줄 거야.

## 🤔 성찰 및 배운 점 (Reflection & Lessons Learned)

`libft`는 나에게 C언어의 '문법'을 넘어 '개념'을 가르쳐준 프로젝트야.

-   **메모리, 그리고 포인터**: C가 왜 강력하고, 동시에 왜 위험한 언어인지 몸소 체험했어. 내가 직접 메모리를 할당하고 해제하면서 그 책임의 무게를 느꼈지.
-   **문제 해결 능력**: `man` 페이지를 친구 삼아, 수많은 오류와 세그폴(segmentation fault)을 디버깅하면서 끈질기게 문제를 파고드는 법을 배웠어.
-   **코드 규약(Norm)**: 42의 엄격한 코드 스타일 규약(Norminette)은 처음엔 족쇄 같았지만, 결국에는 읽기 좋고 유지보수하기 쉬운 코드를 작성하는 습관을 만들어 줬어.

돌이켜보면 `libft`는 단순한 과제가 아니라, C언어라는 세계를 탐험하기 위한 나만의 지도와 나침반을 만드는 과정이었어. 비록 힘들었지만, 이 프로젝트를 통해 얻은 지식과 경험은 앞으로 어떤 어려움이 닥쳐도 헤쳐나갈 수 있는 단단한 기초가 되어주었지. 정말 값진 시간이었다! 💪
