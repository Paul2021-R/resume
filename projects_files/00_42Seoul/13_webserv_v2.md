물론입니다. `webserv`는 42서울 과정의 시스템 프로그래밍 지식을 집대성하는 매우 중요한 과제입니다. 그 깊이와 중요성을 반영하여, 웹 서버의 아키텍처와 핵심 기술 원리를 상세히 분석하는 v2 문서를 작성했습니다.

***

## 🌐 webserv: 비동기 이벤트 기반 서버 아키텍처의 구현 - HTTP/1.1의 재구성

`Inception`이 Docker를 통해 여러 서비스를 조립하는 '인프라 아키텍트'의 관점을 제공했다면, **`webserv`**는 그 인프라의 가장 핵심적인 구성 요소인 웹 서버의 내부를 C++98만으로 직접 설계하고 구현하는 '시스템 아키텍트'의 역할을 요구하는 과제이다. 이 프로젝트는 단순한 소켓 프로그래밍을 넘어, 현대 고성능 웹 서버(NGINX 등)가 채택하고 있는 **비동기 이벤트 기반(Asynchronous Event-driven)** 아키텍처를 직접 구축하는 것을 목표로 한다.

`webserv`는 사용자의 브라우저에서 출발한 HTTP 요청이라는 순수한 텍스트가 어떻게 서버의 문을 통과하고, 내부 로직을 거쳐 의미 있는 응답으로 변환되어 돌아가는지, 그 보이지 않는 통신의 전 과정을 밑바닥부터 재구성하는, 시스템 프로그래밍의 정수가 담긴 여정이다.

---

### 📜 1. 아키텍처 설계: C10K 문제와 이벤트 기반 접근법

전통적인 '요청 당 스레드/프로세스 생성' 모델은 수천, 수만 개의 동시 접속(C10K Problem)을 처리하기에 컨텍스트 스위칭 비용과 메모리 사용량 측면에서 한계가 명확하다. `webserv`는 이 문제를 해결하기 위해 **Non-blocking I/O + I/O 멀티플렉싱**을 기반으로 하는 **이벤트 루프(Event Loop)** 모델을 채택한다.

이 아키텍처는 단일 (또는 소수의) 스레드만으로 수많은 클라이언트의 연결을 효율적으로 처리할 수 있으며, I/O 작업이 진행되는 동안 CPU를 다른 작업에 할당하여 시스템 자원을 극대화한다. 서버의 모든 동작은 '이벤트'가 발생했을 때만 비동기적으로 처리된다.

---

### 🛠️ 2. 핵심 구현 요소: 시스템 콜과 프로토콜의 조립

#### 가. 소켓 프로그래밍: 통신의 관문

소켓은 운영체제의 TCP/IP 스택을 제어하기 위한 프로그래밍 인터페이스(API)이다. 서버의 생명주기는 다음 시스템 콜들을 통해 관리된다.

1.  **`socket()`**: 통신을 위한 엔드포인트를 생성한다.
2.  **`fcntl()`**: 생성된 소켓을 **Non-blocking 모드**로 설정한다. 이는 `accept()`, `read()`, `write()` 등의 I/O 함수가 데이터가 준비되지 않았을 때 즉시 반환되도록 하여, 이벤트 루프 전체가 멈추는 것을 방지하는 핵심적인 단계이다.
3.  **`setsockopt()`**: `SO_REUSEADDR` 옵션을 통해 서버가 비정상 종료된 후 즉시 재시작해도 동일한 포트를 바인딩할 수 있도록 설정한다.
4.  **`bind()`**: 소켓에 특정 IP 주소와 포트 번호를 할당한다.
5.  **`listen()`**: 소켓이 클라이언트의 연결 요청을 수신 대기하도록 설정한다.
6.  **`accept()`**: 연결 요청 큐에서 새로운 클라이언트 연결을 가져와, 통신을 위한 새로운 소켓(커넥션 소켓)을 생성한다.

#### 나. I/O 멀티플렉싱 (`kqueue`): 이벤트 루프의 심장

`kqueue`는 소수의 스레드로 다수의 I/O 이벤트를 효율적으로 관리하기 위한 BSD 계열 운영체제의 고성능 API이다.

* **동작 원리**: 서버는 `kqueue()`로 커널에 새로운 이벤트 큐를 생성한다. 이후 `kevent()` 함수를 사용하여 감시하고자 하는 이벤트(예: '서버 소켓에 새로운 연결 요청이 도착함', '커넥션 소켓에서 읽을 데이터가 있음')를 큐에 **등록(Register)**한다.
* **이벤트 루프**: 서버의 메인 로직은 무한 루프 내에서 `kevent()`를 호출하여 대기하는 것이다. `kevent()`는 등록된 이벤트 중 하나라도 발생할 때까지 프로세스를 대기시키며, 이벤트 발생 시 발생한 이벤트 목록을 반환한다. 루프는 반환된 이벤트들을 순회하며 각각에 맞는 핸들러(새 연결 수락, 데이터 수신 등)를 호출하여 처리한다. 이 구조 덕분에 서버는 실제 작업이 필요할 때만 깨어나 동작하게 된다.

#### 다. 설정 파일 파서: 유연성과 가상 호스팅

`nginx.conf`와 유사한 형식의 설정 파일을 해석하는 파서를 구현해야 한다. 이 파서는 서버의 동작을 코드 변경 없이 제어할 수 있는 유연성을 제공한다.
* **핵심 기능**: 포트 바인딩, 서버 이름 지정, 기본 에러 페이지 경로, 허용 HTTP 메서드, `location` 블록별 라우팅 규칙(루트 디렉토리, CGI 설정 등)을 파싱하여 C++ 객체(예: `ServerConfig`)로 구조화한다.
* **가상 호스팅 (Virtual Hosting)**: 파싱된 설정을 기반으로, 서버는 HTTP 요청 헤더의 `Host` 필드를 확인하여 동일한 IP와 포트로 들어온 요청이라도 각각 다른 `server` 블록 설정에 따라 다른 웹사이트를 서빙할 수 있어야 한다.

#### 라. HTTP/1.1 프로토콜 파서 및 응답 생성기

* **요청(Request) 파싱**: 클라이언트 소켓으로부터 읽어들인 순수한 바이트 스트림을 HTTP/1.1 명세에 따라 파싱한다. 첫 줄인 `Start-Line`에서 `Method` (GET, POST, DELETE), `Request-URI`, `HTTP-Version`을 추출하고, 이후 빈 줄(`\r\n\r\n`)이 나올 때까지 헤더들을 파싱하여 `map`과 같은 자료구조에 저장한다. `Content-Length`가 명시된 POST 요청의 경우, 명시된 길이만큼의 `Body` 데이터를 수신해야 한다.
* **응답(Response) 생성**: 파싱된 요청을 처리한 후, 서버는 다시 명세에 맞춰 응답 메시지를 생성한다. `Status-Line`(`HTTP/1.1 200 OK`), `Headers`(`Content-Type`, `Content-Length` 등), 그리고 `Body`(HTML 파일 내용 등)를 조합하여 클라이언트 소켓에 전송한다.

#### 마. CGI (Common Gateway Interface): 동적 콘텐츠 생성

CGI는 웹 서버가 외부 스크립트(Python, PHP 등)를 실행시켜 동적인 콘텐츠를 생성하기 위한 표준 프로토콜이다.
* **구현**: `fork()`로 자식 프로세스를 생성한 후, `pipe()`로 부모-자식 간 통신 채널을 만든다. 부모 프로세스(서버)는 HTTP 요청 정보를 **환경 변수**(`REQUEST_METHOD`, `QUERY_STRING` 등)로 설정하고, POST 요청의 경우 `Body` 데이터를 자식 프로세스의 `stdin`으로 파이프를 통해 전달한다. 자식 프로세스는 `dup2()`로 자신의 표준 입출력을 파이프에 연결한 뒤, `execve()`로 CGI 스크립트를 실행한다. 스크립트의 실행 결과(표준 출력)는 다시 파이프를 통해 부모 프로세스로 전달되어, 최종 HTTP 응답의 `Body`로 클라이언트에게 전송된다.

---

### ✨ 성찰 및 배운 점

`webserv`는 인터넷의 근간을 이루는 클라이언트-서버 모델과 HTTP 통신의 실체를 코드로 증명해내는 과정이었다.

* **시스템 아키텍처의 이해**: 고성능 서버가 왜 비동기 이벤트 기반으로 설계되어야 하는지에 대한 깊은 공학적 이해를 얻었다. 이는 단순한 코딩을 넘어 시스템 전체의 성능과 확장성을 고려하는 아키텍트의 시각을 길러주었다.
* **프로토콜의 중요성**: HTTP와 CGI라는 엄격한 '약속(Protocol)' 위에서 브라우저와 서버, 서버와 외부 프로그램이 어떻게 질서정연하게 상호작용하는지를 체감했다. 모든 현대 기술은 잘 정의된 프로토콜 위에 서 있음을 깨달았다.
* **저수준 제어의 힘**: C++와 시스템 콜만으로 네트워크 스택의 애플리케이션 계층을 직접 제어하는 경험은, 프레임워크 뒤에 숨겨진 원리를 이해하고 문제의 근본 원인을 진단할 수 있는 강력한 무기가 되었다.

`webserv`를 완성했다는 것은, 브라우저의 URL 입력창 뒤에서 벌어지는 거대한 통신의 오케스트라를 직접 지휘할 수 있는 역량을 갖추었음을 의미하는, 개발자로서의 중요한 이정표이다.