# 🎮 so_long: MiniLibX로 그린 나의 첫 2D 게임, 픽셀 아티스트가 되다!

`push_swap`으로 알고리즘의 쓴맛(?)을 본 나에게 `so_long`은 그야말로 한 줄기 빛과 같은 프로젝트였어. 드디어 이 삭막한 검은 화면을 벗어나 내 코드로 그림을 그리고, 캐릭터를 움직여볼 수 있다니! "간단한 2D 게임을 만들어보세요"라는 이 한 문장은 내 안의 잠자고 있던 게임 개발자의 혼을 깨우기에 충분했지. (물론 그 과정이 순탄하지만은 않았지만 말이야! 😂)

이 프로젝트의 핵심은 단연 **MiniLibX**라는 그래픽 라이브러리를 정복하는 것이었어. C언어로 창을 띄우고, 이벤트를 처리하고, 이미지를 렌더링하는 모든 과정이 신세계 그 자체였지.

## 🎨 MiniLibX, 그래픽 세계로의 초대장

`so_long`은 나에게 MiniLibX라는 마법 도구를 쥐여줬어. 이 도구를 사용해서 그래픽 애플리케이션의 기본 원리를 배울 수 있었지.

-   **`mlx_init` & `mlx_new_window`**: 내 프로그램과 그래픽 서버를 연결하고, 화면에 네모난 창을 띄우는 첫 단계! `Hello World!` 대신 `Hello Window!`를 외쳤던 순간이었어.
-   **이미지 렌더링**: `mlx_xpm_file_to_image`로 `.xpm` 이미지 파일을 불러와서 `mlx_put_image_to_window`로 창에 띄우는 과정은 정말 신기했어. 내가 만든 `asset` 폴더 안의 이미지들이 코드 한 줄로 화면에 그려지는 걸 보면서, "이게 되네?"를 연발했지.
-   **이벤트 기반 프로그래밍**: 가장 중요했던 건 바로 **이벤트 처리**였어. `mlx_loop`라는 무한 루프 안에서 키보드 입력이나 마우스 클릭 같은 이벤트를 기다리다가, 이벤트가 발생하면 미리 등록해둔 함수(`hook`)를 호출하는 방식! `mlx_key_hook`을 사용해서 'W' 키를 누르면 위로 가는 함수를, 'ESC' 키를 누르면 게임을 종료하는 함수를 연결하는 과정은 이벤트 기반 프로그래밍의 정수였어.

## 🗺️ `.ber` 맵 파일에 생명 불어넣기

게임의 무대는 `.ber`라는 확장자를 가진 텍스트 파일이었어. 이 파일을 읽어서 게임 세계를 구축하는 과정은 꽤나 꼼꼼함을 요구했지.

1.  **맵 파싱(Parsing)**: `get_next_line`으로 맵 파일을 한 줄씩 읽어서 2차원 배열(`char **`)에 저장했어. GNL, 너란 녀석... 여기서 또 쓰이는구나!
2.  **맵 유효성 검사**: 이게 또 하나의 관문이었지.
    -   맵이 직사각형인지? (모든 줄의 길이가 같은가?)
    -   벽(`1`)으로 완전히 둘러싸여 있는가?
    -   플레이어(`P`), 출구(`E`), 수집품(`C`)이 규칙에 맞게 존재하는가? (P는 하나, E와 C는 최소 하나 이상)
    -   허용되지 않은 문자가 섞여 있지는 않은가?
    이 모든 조건을 통과하지 못하면 가차 없이 "Error"를 외치고 프로그램을 종료시켜야 했어. 수많은 에러 케이스 맵 파일을 만들어 테스트하며 내 코드의 방어력을 높여갔지.
3.  **맵 렌더링**: 유효성 검사를 통과한 2차원 배열을 이중 반복문으로 순회하면서, 문자에 맞는 이미지를 `mlx_put_image_to_window`로 착착 찍어냈어. '1'이면 벽 이미지, '0'이면 바닥 이미지... 그렇게 텍스트 파일이 한순간에 게임 스테이지로 변신했지!

## 🏃‍♂️ 주인공의 여정과 게임의 규칙

이제 판은 깔렸고, 주인공이 움직일 차례!

-   **이동과 충돌**: `mlx_key_hook`에 연결된 함수는 키가 눌릴 때마다 플레이어의 다음 좌표를 계산해. 그리고 그 좌표가 벽(`1`)이 아니라면, 실제 좌표를 업데이트하고 화면을 다시 그렸지.
-   **상태 업데이트**: 단순히 화면만 다시 그리는 게 아니었어.
    -   플레이어가 있던 원래 자리는 바닥 이미지(`0`)로 덮어주고,
    -   새로운 위치에 플레이어 이미지를 그려서 움직이는 것처럼 보이게 했지.
    -   움직일 때마다 `steps` 변수를 1씩 증가시켜 터미널에 출력해주면서, 최소한의 움직임으로 클리어하려는 유저의 승부욕을 자극했어.
-   **수집과 탈출**: `so_long`의 클리어 조건은 간단했어.
    -   맵의 모든 수집품(`C`)을 먹어야만,
    -   출구(`E`)가 활성화된다!
    플레이어가 'C' 타일로 이동하면 `collect` 카운트를 줄이고, 해당 타일을 '0'으로 바꿨어. 그리고 `collect`가 0이 된 상태에서 'E' 타일에 도착하면... "You Win!" 메시지와 함께 게임이 클리어되는 거야!

## 🤔 성찰 및 배운 점 (Reflection & Lessons Learned)

`so_long`은 C언어로 할 수 있는 것의 범위를 한 단계 넓혀준 프로젝트였어.

-   **그래픽 라이브러리 활용**: MiniLibX를 통해 그래픽 프로그래밍의 기초를 다졌어. 창 생성부터 이미지 렌더링, 이벤트 처리까지, 게임 개발의 기본적인 파이프라인을 경험했지.
-   **상태 관리의 중요성**: 플레이어의 위치, 남은 수집품의 개수, 총 이동 횟수 등 게임의 '상태'를 구조체에 담아 관리하는 것이 얼마나 중요한지 깨달았어.
-   **꼼꼼한 에러 처리**: 다양한 형태의 잘못된 맵 파일을 처리하면서, 어떤 상황에서도 프로그램이 비정상적으로 종료되지 않도록 방어적으로 코딩하는 습관을 기를 수 있었어.

검은 화면에 흰 글씨만 보다가, 내 손으로 직접 만든 캐릭터가 컬러풀한 맵 위를 돌아다니는 것을 봤을 때의 그 뿌듯함! `so_long`은 나에게 코딩의 또 다른 즐거움을 알려준, 정말 '오래도록 길게' 기억에 남을 프로젝트야. 🎮
