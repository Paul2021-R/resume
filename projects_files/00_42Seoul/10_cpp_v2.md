## 🚀 C++ Modules: 절차적 사고에서 객체 지향과 제네릭 프로그래밍으로의 패러다임 전환

42서울의 C++ Module 과정의 프로젝트들은 C언어에 클래스를 더하는 수준을 넘어, 프로그래밍 패러다임 자체를 근본적으로 전환하는 여정이다. 

이 과정은 **절차적 프로그래밍(Procedural Programming)**의 한계를 인지하고, 복잡한 시스템을 구조화하는 새로운 방법론인 **객체 지향 프로그래밍(Object-Oriented Programming)**을 체득하며, 나아가 코드의 재사용성을 극대화하는 **제네릭 프로그래밍(Generic Programming)**의 세계까지 탐험하도록 설계되어 있다.

각 모듈은 C++라는 멀티 패러다임 언어가 제공하는 특정 철학과 도구를 깊이 있게 파고드는 독립적인 연구 과제이다. 이 전체 과정을 통해 개발자는 문제의 성격에 따라 적절한 패러다임을 선택하고 조합할 수 있는 폭넓은 시야와 강력한 무기를 갖추게 된다.

---

### 🗺️ 모듈별 탐험 일지: 개념의 심층 분석

#### 🔹 **Module 00: C++의 기본 골격 - 'C with Classes'**

* **핵심 개념**: **캡슐화(Encapsulation)**. C언어의 구조체와 함수가 분리되어 있던 것과 달리, 클래스는 데이터(멤버 변수)와 그 데이터를 조작하는 행위(멤버 함수)를 하나의 단위로 묶는다. 이는 객체의 상태를 외부로부터 보호하고, 명확한 인터페이스를 통해서만 상호작용하도록 강제하는 첫걸음이다.
* **주요 과제**: `Account` 클래스 등을 통해 생성자(Constructor), 소멸자(Destructor)의 개념을 익히고, 객체의 생성과 소멸이라는 생명주기(Life Cycle)를 직접 관리하기 시작한다. 이는 C++의 가장 중요한 철학 중 하나인 **RAII(Resource Acquisition Is Initialization)**의 기반이 된다. 이 과제부터 '생명주기' 라는 개념을 이해하기 시작했다. 프로그램이나, 객체 등, 기존에는 로직이란 차원에서 접근 하다가, 해당 과제를 하면서부터 주기라는 관점에서 바라볼 수 있게 되었다.

#### 🔹 **Module 01: 자원의 생명주기 관리 - RAII와 참조**

* **핵심 개념**: **자원 관리(Resource Management)**. C언어의 `malloc`/`free`와 달리, C++에서는 `new`/`delete` 연산자를 통해 객체의 동적 할당을 수행한다. 여기서 핵심은 생성자에서 자원을 할당하고(`new`) 소멸자에서 해제(`delete`)하는 **RAII 패턴**을 통해, 자원의 누수를 원천적으로 방지하는 것이다.
* **주요 과제**: `Zombie` 클래스를 통해 동적 할당된 객체의 생명주기를 관리하며 RAII를 연습한다. 또한, 포인터와 달리 null을 허용하지 않고, 가리키는 대상을 변경할 수 없는 **참조자(Reference)**를 통해 더 안전하고 명확한 코드를 작성하는 법을 배운다.

#### 🔹 **Module 02: 연산자 오버로딩 - 사용자 정의 타입의 직관성**

* **핵심 개념**: **연산자 오버로딩(Operator Overloading)**. 아주 유우명한 개발 개념으로 사용자가 직접 정의한 클래스(User-Defined Type)를 `int`, `double`과 같은 내장 타입(Built-in Type)처럼 자연스럽게 사용할 수 있도록 만드는 기술이다. 이는 코드의 가독성과 직관성을 극대화한다.
* **주요 과제**: 고정 소수점 숫자를 표현하는 `Fixed` 클래스를 만들고, 사칙연산, 비교, 증감 연산자 등을 모두 오버로딩한다. 이 과정을 통해 **정규 형식(Canonical Form)**의 중요성, 즉 클래스를 올바르게 동작시키기 위해 필수적으로 구현해야 하는 생성자, 소멸자, 복사 생성자, 할당 연산자 등의 집합을 이해하게 된다.

#### 🔹 **Module 03: 상속 - 코드 재사용과 'is-a' 관계의 표현**

* **핵심 개념**: **상속(Inheritance)**. 객체 지향의 핵심 기둥 중 하나로, 기존 클래스의 기능을 재사용하고 확장할 수 있게 한다. 이는 코드의 중복을 제거하고 클래스 간의 **'is-a' 관계**(예: `ScavTrap` is a `ClapTrap`)를 명확하게 표현한다.
* **주요 과제**: `DiamondTrap` 구현을 통해 다중 상속 시 발생할 수 있는 **다이아몬드 문제(Diamond Problem)**, 즉 부모 클래스의 멤버가 중복으로 상속되는 모호성을 마주한다. 이를 **가상 상속(Virtual Inheritance)**으로 해결하며, 복잡한 클래스 계층 구조를 올바르게 설계하는 방법을 배운다.

#### 🔹 **Module 04: 다형성 - 컴파일 타임을 넘어 런타임으로**

* **핵심 개념**: **다형성(Polymorphism)**. 기반 클래스 포인터나 참조를 통해 파생 클래스의 객체를 다룰 수 있게 하는, 객체 지향의 정수이다. 이는 **가상 함수(Virtual Function)**를 통해 구현되며, **동적 바인딩(Dynamic Binding)**, 즉 실제 호출될 함수가 컴파일 시점이 아닌 런타임에 결정되도록 한다.
* **주요 과제**: `Animal`과 같은 **추상 기본 클래스(Abstract Base Class)**를 순수 가상 함수(`=0`)를 이용해 정의한다. 이는 파생 클래스가 반드시 구현해야 할 **인터페이스(Interface)**를 강제하는 역할을 한다. 또한, 기반 클래스 포인터로 객체를 삭제할 때 발생할 수 있는 메모리 누수를 막기 위해 **가상 소멸자(Virtual Destructor)**의 필요성을 체득한다.

#### 🔹 **Module 05: 예외 처리 - 오류에 대한 견고한 대응**

* **핵심 개념**: **예외 처리(Exception Handling)**. C언어의 반환 값을 통한 오류 처리 방식의 한계를 극복하고, 오류 처리 로직과 정상적인 실행 로직을 분리하는 현대적인 방법이다. `try-catch-throw` 구문을 통해 예외가 발생했을 때 프로그램의 흐름을 안전하게 제어하고, **스택 풀기(Stack Unwinding)**를 통해 지역 객체들의 소멸자를 호출하여 자원을 안전하게 해제한다. 이 과제를 해본 이래로 try-catch 의 중요성을 이해했으나, 여전히 아쉬운 점은 어떤 식으로 관리하는 것이 좋은가? 에 대해선 항상 애매하다는 점이다. 

#### 🔹 **Module 06: C++ 형변환 - 명시적이고 안전한 타입 변환**

* **핵심 개념**: **의도를 명시하는 형변환**. C 스타일의 무분별한 형변환 대신, C++은 `static_cast`, `dynamic_cast`, `const_cast`, `reinterpret_cast`의 네 가지 명시적 캐스트를 제공한다. 이는 개발자의 의도를 코드에 명확히 드러내고, 컴파일러가 더 많은 오류를 검출할 수 있도록 돕는다.
* **주요 과제**: `dynamic_cast`를 통해 런타임에 타입 정보를 확인하며 안전하게 다운캐스팅(Down-casting)하는 방법을 익힌다. 이 개념들 자체는 이해가 쉬웠지만, 결과적으로 형변환 과정의 에러핸들링이라던가.. 할게 많았다. 

#### 🔹 **Module 07: 템플릿 - 코드의 일반화와 제네릭 프로그래밍**

* **핵심 개념**: **제네릭 프로그래밍(Generic Programming)**. 특정 자료형에 종속되지 않고, 다양한 자료형에 대해 동작할 수 있는 범용적인 코드(함수 템플릿, 클래스 템플릿)를 작성하는 패러다임이다. 이는 **컴파일 타임 다형성**을 통해 코드 중복을 최소화하면서도 타입 안전성과 성능을 모두 확보한다. 이 부분은 가장 흥미로우면서도, 재미있던, 그러나 동시에 과연 어떻게 써야 하는가? 라는 차원에서 고민이 된 기술이었다. 다른 언어 프로그래밍 과정에서도 제네릭스는 꼭 나오고, 실제로도 중요한 것은 사실이지만, 제네릭스가 실제 서비스에서 운용되게 되면, 어지간하면 복잡도를 높이고 상호 소통이 안되면 기술 부채가 되는 느낌이라... 적절한 좋은 레퍼런스가 될만한 사례가 있나? 싶었다.

#### 🔹 **Module 08: STL - 컨테이너, 반복자, 알고리즘의 삼위일체**

* **핵심 개념**: **STL(Standard Template Library)**. C++ 표준 라이브러리의 핵심으로, **컨테이너(Container)**, **알고리즘(Algorithm)**, 그리고 이 둘을 연결하는 **반복자(Iterator)**의 세 요소로 구성된다. STL의 위대함은 반복자라는 통일된 인터페이스를 통해, 어떤 컨테이너라도 어떤 알고리즘과 함께 동작할 수 있도록 설계되었다는 점에 있다. 신세계...! 객체 지향 언어가 왜 그렇게 중요한지(...) 이 모듈을 기준으로 정말 많이 깨달았었다.
* **주요 과제**: `vector`, `list`, `map` 등 다양한 컨테이너의 내부 구조와 시간 복잡도를 이해하고, 각 상황에 맞는 최적의 컨테이너를 선택하는 능력을 기른다.

---

### ✨ 대장정을 마치며

C++ Module 00부터 08까지의 여정은 C++라는 언어를 절차적, 객체 지향적, 그리고 제네릭 프로그래밍의 관점에서 입체적으로 이해하게 만든 심도 있는 훈련 과정이었다. 각 모듈은 복잡한 소프트웨어를 구축하기 위해 필요한 각기 다른 종류의 '무기'를 제공했다. 이 경험은 단순히 C++ 언어 자체에 대한 숙련도를 넘어, 문제의 본질을 파악하고 그에 가장 적합한 프로그래밍 패러다임을 선택하여 코드를 구조화하는 소프트웨어 설계자로서의 역량을 길러주었다.