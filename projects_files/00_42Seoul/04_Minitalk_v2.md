## 📢 Minitalk : 신호(Signal)로 쌓아 올린 통신의 규약(Protocol)

`printf`가 데이터의 '표현'을 다루는 과제였다면, `Minitalk`는 한 걸음 더 나아가, 분리된 프로세스들 사이에 어떻게 '의미'를 전달할 수 있는지에 대한 근본적인 질문을 던진다. 이 과제의 요구사항은 지극히 미니멀리즘하다: 네트워크 소켓 없이, 오직 두 종류의 유닉스 시그널(`SIGUSR1`, `SIGUSR2`)만을 이용해 문자열을 전송하라.

본래 시그널은 프로세스를 중단시키거나(`SIGINT`), 특정 상태를 알리는 등 단방향의 강제적인 '사건(Event)'을 통지하기 위한 원시적인 메커니즘이다. `Minitalk`는 이 제약 조건을 역으로 이용하여, 가장 혼란스럽고 원시적인 통신 수단 위에 어떻게 질서정연한 '규약(Protocol)'을 세우고 안정적인 통신 채널을 구축할 수 있는지 온몸으로 증명해야 하는, 시스템 프로그래밍의 정수가 담긴 과제였다.

### 💡 통신의 첫 단추: 약속(Convention)의 탄생

모든 통신은 '약속'에서 시작한다. `Minitalk`의 세계에서는 두 개의 시그널이 알파벳의 역할을 맡는다.

* `SIGUSR1`은 비트(bit) **0**을 의미한다.
* `SIGUSR2`는 비트(bit) **1**을 의미한다.

이 지극히 단순한 약속 하나가 무질서한 신호에 의미를 부여하는 첫걸음이다. 문자 'A'(ASCII 65, 이진수 `01000001`)를 보내는 행위는, 이제 `SIGUSR1`, `SIGUSR2`... 와 같은 8개의 시그널을 순차적으로 발신하는 행위로 번역된다. 이는 현대 네트워크 통신의 가장 밑단에 있는 물리 계층(Physical Layer)에서 전기 신호의 전압 차이를 0과 1로 해석하는 원리와 정확히 일치한다. 우리는 시그널을 통해 가장 원시적인 형태의 물리 계층을 직접 구현한 것이다.

### 🤝 프로토콜의 설계: 주소 지정, 직렬화, 그리고 동기화

단순히 0과 1을 보낼 수 있다고 해서 통신이 완성되지는 않는다. 의미 있는 데이터 교환을 위해서는 정교한 프로토콜이 필요하다.

1.  **주소 지정 (Addressing) - `PID`**: 서버는 시작과 동시에 자신의 `PID(Process ID)`를 출력한다. 이는 네트워크에서 서버가 자신의 IP 주소와 포트 번호를 알리는 것과 같다. `PID`는 운영체제가 각 프로세스에게 부여한 고유한 주소이며, 클라이언트는 `kill` 시스템 콜을 통해 이 주소로 정확하게 신호를 보낼 수 있다. 통신의 가장 기본인 '누가 누구에게' 보내는지를 명확히 하는 단계다.
2.  **직렬화와 역직렬화 (Serialization & Deserialization) - 비트 연산**:
    * **클라이언트 (송신자)**: 문자(char)라는 고수준 데이터를 `(character >> i) & 1`과 같은 비트 연산을 통해 8개의 비트 스트림으로 분해(직렬화)한다. 이는 통신 채널(시그널)을 통해 보낼 수 있는 형태로 데이터를 가공하는 과정이다.
    * **서버 (수신자)**: `sigaction`을 통해 등록된 핸들러 함수는 비동기적으로 도착하는 시그널들을 수신한다. 이 핸들러는 `char_byte = (char_byte << 1) | bit;` 코드를 통해 흩어져서 도착한 비트들을 다시 8비트의 문자(char)로 조립(역직렬화)한다. 이는 외부의 비동기적 이벤트를 처리하는 **이벤트 기반 프로그래밍(Event-driven programming)**의 핵심 모델을 직접 구현하는 경험이었다.
3.  **흐름 제어 (Flow Control) - 동기화**: 만약 클라이언트가 일방적으로 시그널을 폭주시키면 서버는 이를 모두 처리하지 못하고 유실된다. 이를 막기 위해 **핸드셰이크(Handshake)** 기반의 동기화 프로토콜을 도입해야 했다.
    * 클라이언트는 1비트를 보낸 후 `pause()`로 응답을 기다린다.
    * 서버는 1비트를 성공적으로 처리한 후, `kill`을 통해 클라이언트에게 **ACK(Acknowledgement)** 신호를 보낸다.
    * ACK 신호를 받은 클라이언트는 비로소 다음 비트를 보낸다.
    * 이 '보내고-받고-확인하는' 과정은 신뢰성 있는 통신의 대명사인 TCP 프로토콜의 흐름 제어 원리와 정확히 같다. 우리는 가장 원시적인 재료로 현대적인 통신 프로토콜의 핵심 개념을 재창조한 것이다.

### ✨ 성찰 및 배운 점

`Minitalk`는 운영체제와의 깊은 교감을 통해 통신의 본질을 탐구하게 한 과제였다.

* **프로토콜 설계의 본질**: 통신은 단순한 데이터 전송이 아니라, 양측이 동의한 엄격한 '규칙의 집합' 위에서 이루어짐을 깨달았다. 주소 지정, 데이터 표현, 순서 보장, 오류 제어 등 모든 현대 네트워크 프로토콜에 담긴 철학을 가장 단순한 형태로 압축해서 경험할 수 있었다.
* **비동기 프로그래밍의 이해**: 프로그램의 흐름이 나의 코드가 아닌 외부의 이벤트(시그널)에 의해 결정되는 비동기 모델을 직접 다루어 보았다. 이는 UI 이벤트 처리, 비동기 I/O 등 현대 프로그래밍의 핵심 패러다임을 이해하는 중요한 발판이 되었다.
* **추상화에 대한 감사**: 매일 당연하게 사용하던 `TCP/IP` 소켓 통신이 얼마나 많은 복잡성을 감추고 우리에게 편리함을 제공하는지, 가장 낮은 수준의 통신을 구현해보고 나서야 비로소 실감하게 되었다. 추상화의 소중함은 그것이 없을 때 가장 명확하게 드러난다.

클라이언트에서 입력한 문자열이 서버 터미널에 조금은 느리지만 한 글자 한 글자 정확히 출력되는 모습. 그것은 단순한 결과가 아니었다. 무질서하게 날아다닐 수 있는 신호들을 길들여, 그 위에 '규약'이라는 질서를 부여하고, 마침내 '의미'를 만들어내는 데 성공한 지적 희열의 순간이었다.