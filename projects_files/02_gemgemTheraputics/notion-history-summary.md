## 2024 시험성적서 SW 인수인계.md

Patient Mode 기능에 대한 설명서로, 웹캠을 통해 사용자의 손동작(C2, F3, F4 제스처)을 인식하고 평가하여 맞춤형 재활 가이드를 제공하는 기능입니다. `webapp.py`를 중심으로 `HandDetector`, `predictions_from_model`, `gemgem_utils`를 통해 동작하며, 3회 시도 후 최고 레벨을 기록하고 `gemgem_utils.py`의 평가 함수를 통해 최종 등급을 결정합니다. 새로운 제스처를 추가하려면 ONNX 모델 준비, `webapp.py` 수정, `gemgem_utils.py`에 평가 로직 구현, 결과 리포트 마크다운 파일 추가의 4단계가 필요합니다.

## 가격 인상 시스템 API 및 테스트 시나리오.md

구독 서비스의 가격 인상 로직과 테스트 계획을 상세히 설명하는 문서입니다. 가격 인상 로직은 서버 전역 설정(인상 날짜, 요금제별 설정)과 사용자별 결제 인상 플래그(`non_target`, `target`, `accept`, `deny`) 및 스탬프를 통해 관리됩니다. 유저 로그인 시 결제 상태를 파악하여 인상 동의 여부를 확인하고, 동의 시 상태를 갱신합니다. 구글과 애플 플랫폼의 차이점(구독 취소 처리)을 고려하며, `IncreasementAcception` 플래그로 인상 시점을 구분합니다. 테스트 계획은 Phase 1(환경 준비: 앱 빌드, 서버 배포, 플랫폼 설정), Phase 2(테스트 계정 준비: 각 플랫폼별 4개 계정), Phase 3(핵심 테스트 시나리오: 동의, 거절/유예, 무시 후 만료, 신규/무료 유저), Phase 4(회귀 테스트)로 구성됩니다. 각 시나리오별 예상 결과와 검증 포인트(DB 상태, 로그, 믹스패널 이벤트)가 명시되어 있습니다.

## 가상 메모리 vs 스왑.md

가상 메모리(VIRT)와 스왑(Swap)의 개념, 역할, 그리고 스왑 영역 할당 여부에 따른 시스템 동작을 설명합니다. VIRT는 프로세스가 사용하는 전체 가상 메모리 공간을 의미하며, RES(Resident Set Size)와 함께 실제 메모리 사용량을 파악하는 데 중요합니다. 스왑은 RAM 부족 시 하드 디스크를 RAM처럼 활용하는 기술로, 시스템 성능 저하 방지 및 더 많은 프로그램 동시 실행을 돕습니다. 스왑 영역이 할당되지 않은 경우는 RAM이 충분하거나 의도적으로 비활성화한 경우이며, RAM 부족 시 시스템 불안정의 단점이 있습니다. 문서에서는 4GB 메모리 시스템에서 스왑 적용 방향성으로 안정성 우선(2GB 스왑, `swappiness=10`), 성능 우선(스왑 미적용 후 모니터링), zram 사용을 제안합니다. 결론적으로 개발 서버는 스왑 미설정, 프로덕션 서버는 안정성을 위해 2GB 스왑 할당을 권장합니다. 마지막으로 스왑 파일 생성, 권한 설정, 활성화, `/etc/fstab` 등록, `swappiness` 조절 등 스왑 설정 과정을 상세히 안내합니다.

## 각 플랫폼 별 스토어 구독 인상 정책과 기본 원칙.md

Apple(iOS)과 Google(Android)의 스토어 구독 가격 인상 정책과 이에 따른 기술 요구사항을 다룹니다. 두 플랫폼 모두 사전 동의(Opt-in)가 필수이며, 미동의 시 구독이 자동 만료됩니다. 개발사 자체 인앱 안내 UI가 강력히 권장됩니다. 서버 측에서는 유저 상태 파악 API, `PRICE_INCREASE` (Apple) 및 `SUBSCRIPTION_PRICE_CHANGE_CONFIRMED` (Google) 알림 처리, `EXPIRED` 알림 상세 처리(Apple)가 필요합니다. 가격 인상 로직은 서버 전역 설정과 유저별 플래그를 통해 관리되며, 유저 로그인 시 결제 상태를 파악하여 동의 여부를 확인하고 클라이언트에 알림을 보냅니다. 가격 인하 로직은 플랫폼에서 자동으로 처리됩니다. 클라이언트 측에서는 가격 인상 안내 UI 표시 여부 판단 API, Apple의 경우 네이티브 메서드 호출 기능 검증 및 자체 UI 구현 필요성, Google의 경우 PlayStore 구독 관리 화면으로 리다이렉션이 주요 작업입니다. 로깅 전략, 동의/비동의 UI, 테스트 전략 수립도 중요하게 언급됩니다.

## 간단버전) 서버 CICD 배포.md

서버 CICD 배포의 기본 구조와 두 가지 배포 방법을 설명합니다. 무중단 배포를 지향하지만 현재는 수동 관리 상태입니다. 자동 업데이트(AWS ECR, launch template)와 수동 업데이트(AWS ECR, SSH 접속, docker compose) 방식이 있습니다. 배포를 위한 필수 사항으로 AWS 보안 그룹 설정과 AWS CLI 설정(설치 및 구성 방법 상세 안내)을 언급합니다. 실행 절차는 `yarn build:dev`로 빌드, `yarn push`로 ECR 업로드 후 수동 방식(SSH 접속, docker compose 명령) 또는 자동 방식(AWS Auto Scaling 그룹 용량 조절)으로 나뉩니다. API 서버는 그레이스풀 셧다운이 적용되어 HTTP 로깅 및 신호 처리 후 종료되며, Discord 알림을 통해 서버 시작 신호를 확인할 수 있습니다.

## 개발 환경 - gemgem-care-report 설정.md

운동 리포트의 MVP 기능을 위한 React 사이트인 `gemgem-care-report`의 개발 환경 설정 방법을 설명합니다. 설치 필수 사항으로 NodeJS 19+, NPM 또는 Yarn, PM2를 명시합니다. 설치 과정은 `git clone`, `npm install`, `env` 파일 설정, `npm run start`로 구성됩니다. 참고 사항으로, 현재 단일 인스턴스에서 운영되며 dev/staging/prod 환경 모두 단일 서버 내에서 처리된다는 점과 함께 환경 변수 설정 예시를 제공합니다.

## 개발환경 - gemgem-api 설정.md

`gemgem400` 서비스의 API 서버 개발 환경 설정 방법을 상세히 설명합니다. Node 22 LTS, NestJS 최신 버전, Yarn 1.22.22, Docker 28v 등의 의존성 설치가 필요하며, VSCode 확장 프로그램도 권장됩니다. 환경 변수 파일(`env.local`), MongoDB 및 Redis 연결 정보, Apple 및 Google 인증서 파일(`assets/certificate` 경로에 저장) 설정이 필수입니다. 설정 과정은 의존성 설치, 환경 변수 및 인증서 파일 배치, 로컬 MongoDB/Redis 연결(`yarn set:local` 사용), `tsconfig.json` 파일 생성, `phoneBook` 로컬 적용 순으로 진행됩니다. NCP, Apple, Google, Notion 연결 시 발생할 수 있는 에러 상황에 대한 간략한 설명과 함께 `yarn start:local`, `yarn start:debug` 등의 실행 명령어를 안내합니다.

## 결제 서비스 구현.md

앱스토어 및 플레이 스토어의 구독 결제 구현 가이드입니다. 새 구매 검증 절차는 클라이언트가 결제 정보를 서버에 전달하고, 서버는 인앱 플랫폼과 통신하여 영수증을 요청, 검증 후 상품을 지급하는 방식입니다. 재구매 검증 절차는 인앱 플랫폼에서 정기 결제가 수행되면 서버로 이벤트를 전달하고, 서버는 사용자 데이터를 갱신하여 클라이언트가 결제 정보를 요청할 때 유효한 정보를 제공하는 방식입니다. 결제의 원칙은 클라이언트 측 결제 진행을 기본으로 하되, 서버는 영수증 검증, 구독 상태 관리, 권한 부여 등의 역할을 수행합니다. Apple과 Google 플랫폼 간의 결제 프로세스, 영수증 검증 방법, 실시간 상태 업데이트 방식의 차이점을 비교합니다. 이벤트 수신 및 API 서버 구조에서는 `UserDto`에 결제 관련 정보(`userPaymentsMethod`, `subscriptionStatus`, `transactionIdentifier`, `validDate`, `expectedNextPayment`, `serverNowDateTime`)를 추가하여 결제 여부를 판단하는 방법을 제시합니다. Apple과 Google의 데이터 구조 예시를 제공하며, 기존 API의 결제 문제점(Android 영수증 파싱 오류)과 해결 방안(클라이언트에서 Payload만 문자열로 전송)을 언급합니다.

## 결제 연동 기능명세서.md

결제 상품 설정, 서버 및 클라이언트 측 기능 구현, 테스트, 서버 데이터 구조 개선 등 결제 시스템 연동에 대한 상세한 기능 명세입니다. 상품명 변경 및 SILVER, GOLD 상품 신설을 포함합니다. 서버 기능은 각 상품 파싱 및 UserDTO에 속성 추가, 결제 시 속성 판단 로직, 기존 15만원 상품을 임상 전용으로 분리하는 작업이 우선순위로 언급됩니다. 카카오톡 메시지 관리 및 전송 기능, 스토어 이벤트(업그레이드, 다운그레이드) 대응, 네이버 구독 시스템 연동(향후)도 포함됩니다. 클라이언트 기능은 결제 화면 UI/로직 변경, Unity Purchasing 연동, 업그레이드 기능 구현이 주요 내용입니다. 서버 데이터 구조 개선은 `UserDto`에 결제 관련 필드를 추가하여 결제 상태를 상세하게 관리합니다. `subscriptionId`는 각 플랫폼별 상품 ID를 매핑합니다. 무료 접속 기능은 기존 프로모션 기능을 `user`의 `dto` 설정(`free-basic`, `free-silver`, `free-gold`)으로 대체하여 서버에서 프로모션 기능을 완전히 배제하는 방안을 제시합니다.

## 계정 시스템 방향성 - 기능문서.md

계정 시스템의 주요 방향성을 제시하고, 각 방식(휴대전화, 소셜 로그인, 이메일 주 계정)의 장단점을 분석합니다. 휴대전화 로그인 방식은 변경 시 로직 처리 및 본인인증 문제로 부적합하며, 소셜 로그인 단독 사용은 마이그레이션 및 부모 계정 공유 문제로 단독 사용이 어렵다고 판단합니다. 이메일 주 계정 방식을 유지하되, 구글/애플 계정을 이메일과 연동하여 어떤 방식으로든 로그인이 가능하도록 기능을 보완하는 방향을 제안합니다. 각 방식의 장단점과 함께 로컬 로그인, 소셜 로그인, 개인정보 설정(소셜 로그인 연동/해지, 비밀번호 찾기, 휴대전화 번호 변경, 탈퇴 기능)에 대한 상세 로직을 설명하며, 탈퇴 시 데이터 처리 정책을 명시합니다.

## 구글 Play Developer Reference 정리.md

Google Play Developer API의 주요 기능과 사용 방법을 정리한 문서입니다. API는 크게 Subscriptions and In-App Purchases API(인앱 구매 및 정기 결제 관리)와 Publishing API(앱 업로드 및 게시)로 나뉩니다. 이 외에도 게임 서비스, 리포팅, 리뷰 답변, 권한 관리, 무효화된 구매 처리 등 다양한 기타 API가 존재합니다. API 사용을 위해서는 Google Cloud 프로젝트 생성, API 사용 설정, 그리고 Google Play Developer API에 액세스할 수 있는 서비스 계정 또는 OAuth 클라이언트 구성이 필요하며, 대부분의 경우 서비스 계정 사용이 권장됩니다. API 할당량은 하루 200,000개로 제한되며, `Edits` 메서드를 통해 앱의 여러 변경사항(APK, 트랙, 스토어 등록 정보 등)을 한 번에 준비하고 배포할 수 있는 워크플로를 상세히 설명합니다.

## 구독 시스템 추가 개선안.md

구독 시스템의 추가 개선안으로, 현재 최소 사양으로 구현된 결제 시스템을 구글 및 애플 스토어의 다양한 이벤트에 대응하도록 확장하는 내용을 다룹니다. 서버 측에서는 구글의 `SUBSCRIPTION_RECOVERED`(결제 복구), `SUBSCRIPTION_ON_HOLD`(결제 보류), `SUBSCRIPTION_RESTARTED`(정기 결제 복원), `SUBSCRIPTION_PAUSED`(구독 일시 정지), `SUBSCRIPTION_PAUSE_SCHEDULE_CHANGED`(구독 일시 정지 일정 변경) 이벤트와 애플의 `DID_CHANGE_RENEWAL_STATUS` (AUTO_RENEW_ENABLED: 자동 갱신 활성화), `DID_FAIL_TO_RENEW` (GRACE_PERIOD: 구독 갱신 실패 및 유예 기간 알림), `REFUND`(환불), `GRACE_PERIOD_EXPIRED`(결제 실패 유예 기간 만료) 이벤트 처리가 필요합니다. 각 이벤트별 소요 기간이 명시되어 있습니다. 논의 사항으로는 구글과 애플의 상이한 유예 기간 정책 통일 및 대응 방안, 그리고 다운그레이드/업그레이드 기능 구현 필요성 등이 언급됩니다.

## 구독료 인상 확인 API.md

구독료 인상 및 사용자 동의 확인을 위한 API를 설명하는 문서입니다. `auth.guard`에서 구독 인상 마이그레이션이 자동 진행되며, `userDto`의 `subscriptionIncreaseState`(`non_target`, `target`, `deny`, `accept`)와 `subscriptionIncreaseDate` 값을 통해 사용자 상태를 판단합니다. `GET /subscriptions/status/increasement` API를 통해 현재 유저의 구체적인 상황(대상 여부, 동의 시점, 해당하는 구독제 ID, 해당 구독 상품의 인상 날짜)을 직접 서버에 요청하여 조회할 수 있습니다. 각 `subscriptionIncreaseState` 값에 따라 팝업 알림을 띄워줄 필요가 있는지 여부가 명시되어 있습니다.

## 그라파나 + 대시보드 적용 계획 검토.md

Grafana와 대시보드를 활용한 모니터링 시스템 구축 계획을 검토하는 문서입니다. HTTP/HTTPS 요청 추적, MongoDB 연결 및 데이터 시각화, AWS 인스턴스 모니터링 및 알림 기능을 구현 목표로 합니다. NestJS Prometheus exporter, Grafana MongoDB 데이터 소스 플러그인, Node Exporter, Prometheus를 활용한 구현 방식을 제시하며 각 기능별 예상 소요 시간과 리소스 사용량을 분석합니다. 특히 MongoDB 시각화는 Grafana Enterprise 버전에서만 지원되거나 사설 플러그인 사용이 막혀 있어, MongoDB Atlas Charts 등의 대안을 모색해야 함을 언급합니다. 전체 소요 기간은 빠르게 진행할 경우 약 1주일 3일로 예상하며, 실시간 모니터링을 위해 별도의 소형 서버가 필요할 수 있고, 나머지는 기존 인스턴스 내부에 설치해도 큰 부담 없이 사용 가능하다고 결론 내립니다.

## 네트워크 모니터링 도구 bmon 사용 설명.md

CLI 기반 네트워크 트래픽 모니터링 도구인 `bmon`의 사용법을 설명하는 문서입니다. `bmon`은 네트워크 인터페이스의 실시간 트래픽을 모니터링하며, 화면은 상단의 인터페이스 및 전송/수신 정보(RX bps: 초당 수신 속도, TX bps: 초당 송신 속도, pps: 초당 패킷 수, %: 상대적 사용 비율), 하단 좌측의 RX(수신) 그래프, 하단 우측의 TX(송신) 그래프로 구성됩니다. 각 지표의 의미와 함께 `d`(상세 통계), `i`(추가 정보), `?`(도움말), `q`(종료) 단축키를 설명합니다. `bmon`을 통해 네트워크 유휴 상태, 작은 패킷의 빈번한 전송, 서버의 데이터 전송량 등을 파악할 수 있는 사용 팁도 제공합니다.

## 동시접속막기 기능 명세.md

동시접속 방지 기능의 명세로, 클라이언트 1.5일, 서버 3일, 테스트 0.5일의 일정을 예상합니다. Redis를 활용하며, 개발/테스트 환경은 1vCPU/1GB RAM, 프로덕션은 2vCPU/4GB RAM을 권장합니다. MemoryDB는 비용 문제로 당장은 고려하지 않습니다. 기획 방향은 최초 접속 시 기기 점유, 다른 기기 접속 시 재점유 요청(YES: 기존 기기 블랙리스트, NO: 메인 화면 이동)으로 진행됩니다. 클라이언트는 재점유 요청, 헬스 체크, 알림창 기능을, 서버는 Redis 설정, 점유 요청 API, 헬스 체크 API, 버퍼 기능을 구현합니다. 서버 동시접속 막기 구조는 Redis와 `nestjs-redis` 라이브러리를 기반으로 하며, 메인 스레드 부하를 줄이기 위해 Bull 라이브러리를 활용한 백그라운드 처리를 제안합니다. 마지막으로 API 요청/응답 구조와 특수 계정의 동시 접속 우회 기능(`concurrent-able` 속성)을 설명합니다.

## 무료체험 API 정리.md

무료 체험 기능 관련 API를 정리한 문서입니다. 기존 `freeTrialStartDate`만 제공하는 방식의 문제점(로컬 타임 변경 시 계산 오류)을 개선하고 보안을 강화하는 것이 목표입니다. 무료 체험 시작 시 `POST /users/trial-time` API를 통해 `freeTrialStartDate`를 전송하며, 무료 체험 시간 확인은 `GET /users/trial-time` API를 통해 `freeTrialStartDate`(무료 체험 시작일), `freeTrialEndDate`(무료 체험 종료일, 시작일 + 7일), `currentTime`(현재 서버 기준 시간)을 받습니다. `common/constants/`의 `freeTrialPeriod` 변수가 요일을 관리합니다.

## 무제 1.md

서버 점검 시 클라이언트 접속을 막는 간이 기능 구현에 대한 문서입니다. 서버는 Nginx 설정을 통해 특정 설정 파일이 존재할 때 모든 요청에 503 응답을 보냅니다. 클라이언트는 이 메시지를 확인하여 점검 시간(시작일, 종료일)을 표시하고 로그인을 막으며, 1초 간격으로 서버에 요청을 보냅니다. 서버 점검이 끝나 503 응답이 오지 않으면 클라이언트는 재시작(로딩)을 통해 정상 서비스로 전환됩니다.

## 무제.md

AWS EC2 인스턴스에서 운영되는 서버들에 대한 정보를 담고 있는 문서입니다. `mlserver-loadtest`는 Pranav 2022 및 디피니티 2023 서버를 Flask 기반으로 3000, 3001 포트에서 실행하며, 성공/실패 값을 전달하고 C2 손동작을 인식합니다. `gemgem-mlserver-01`은 Pranav 2024 서버를 FastAPI 기반으로 3002 포트에서 실행하며, easy, good, great 3가지 등급 값을 전달하고 b2, c2, f3, f4 손동작을 인식합니다. 각 서버의 도메인 및 인스턴스별 접속 확인 방법과 실행 명령어를 제공합니다. 또한, 네트워크 테스트 결과 7~8명 동시 연결이 적절하며, 9명 연결 시 최대 450MB, 7명 연결 시 최대 328MB의 네트워크 입력 바이트가 발생함을 명시합니다.

## 미니게임 모듈 정리 자료.md

미니게임 모듈의 기본 목적, 핵심 구조, API 시퀀스 및 데이터 구조를 설명하는 문서입니다. 미니게임은 플레이어의 동적 데이터(`PlayerDynamicData`)와 게임 설정(`SettingsValues`)을 관리하며, 각 게임별 서비스는 게임 결과 처리 및 데이터 초기화 로직을 담당합니다. `MiniGamesService`는 모든 미니게임을 총괄하며, 스케줄링 서비스를 통해 매일 자정 이후 미니게임 데이터를 초기화합니다. `ChildrenController`는 클라이언트 요청을 처리하는 API 엔드포인트 역할을 합니다. 개선 가능한 부분으로 `MiniGamesService`의 역할 분담, 게임 설정 관리 일원화, 게임 데이터 처리 추상화, 이벤트 기반 아키텍처 도입을 제안합니다. 마지막으로 미니게임 데이터 구조 예시와 API 요청/응답 구조를 상세히 설명합니다.
---
### 미니게임 변경 사항 , 양치 게임 , 요리게임 기능 문서.md
이 문서는 미니게임(컬러스터디, 미니게임 컬렉션, 양치 게임, 요리 게임)의 변경 사항을 다룹니다. 주요 변경 사항은 운동 리포트 로깅을 위해 `POST /children/mini-games/result` 대신 `POST /children/therapy-results` API를 사용하도록 변경하고, 새로운 `therapy-results` API의 바디 구조를 정의합니다. 또한 양치 게임과 요리 게임의 일일 제한 로직은 기존 `tryCounter`를 활용하며, `GET /children/mini-games/save-data/:id`를 통해 일일 제한을 확인하는 내용을 포함합니다.

---
### 빌드머신 구축 예상 일정 산정.md
이 문서는 Unity 앱의 안드로이드 및 iOS 빌드 자동화를 위한 빌드 머신 구축 예상 일정을 산정합니다. 젠킨스 마스터(AWS EC2)와 슬레이브(Mac Studio)를 JNLP 방식으로 연결하고, GitHub Dev 브랜치 기반 정기 빌드 및 디스코드 알림, 스토리지 관리 자동화를 목표로 합니다. 총 예상 소요 시간은 46시간(약 6일)이며, Unity 빌드 환경 설정에 추가 시간을 반영했습니다. 장기적인 유지보수를 위해 신규 설정을 통한 안정적인 구조 구축을 제안합니다.

---
### 서버 관리 계획.md
이 문서는 서버 관리 계획에 대해 설명합니다. 프로덕션 서버는 `prod-api.gemgem.me` 및 `prod-care.gemgem.me`로 도메인을 변경하고, 현재 개발 서버는 `staging-api.gemgem.me` 및 `staging-care.gemgem.me`로 변경하여 리뷰 및 검증용으로 활용합니다. 신규 개발 서버는 `dev-api.gemgem.me` 및 `dev-care.gemgem.me`로 구축하여 개발용으로 사용합니다. 각 서버별 할 일(도메인 변경, 케어리포트 분리, DB 변경 등)을 정리하고, 결제 시스템(구글, 애플) 관련 유의사항 및 개선 방안을 언급합니다.

---
### 서버 점검 기능.md
이 문서는 서버 점검 시 클라이언트 접속을 막는 기능에 대해 설명합니다. Nginx 설정을 통해 특정 파일이 존재할 경우 모든 요청에 503 응답을 보내고, 클라이언트는 이 메시지를 확인하여 점검 시간(시작일, 종료일)을 표시하고 로그인을 막습니다. 점검이 끝나면 클라이언트는 재시작하여 정상 서비스로 전환됩니다. 점검 메시지에는 메시지 내용, 시작일, 종료일이 포함됩니다.

---
### 서버 최적화 계획 - 로깅 전용 서버 구축.md
이 문서는 서버 최적화 방안으로 로깅 전용 서버 구축 계획을 제시합니다. 메인 서버의 로깅 부담을 최소화하고, 로깅 관련 작업(HTTP 로깅, 디스코드 웹훅 등)을 로깅 서버로 분리하여 처리합니다. ECR에서 동작하는 컨테이너 형태로 메인 서버와 로깅 서버가 통신하며, 궁극적으로는 카프카와 같은 중간 서비스를 통해 성능과 안정성을 확보하는 것을 목표로 합니다.

---
### 손 동작 배정 기능.md
이 문서는 손 동작 배정 기능 구현에 대한 계획을 설명합니다. 센터의 지속적인 요청으로 손 동작, 손 방향, 기간 등을 지정할 수 있도록 구현이 필요하며, 현재 경희님에게 필요한 내용을 요청한 상태입니다. 서버 측에서는 동작 스케줄 데이터 구조 작업(1일), 동작 스케줄 CRUD API 구현(1일), 동작 스케줄 비즈니스 로직 구현(경희님 요청 반영 후 세분화 예정)이 필요합니다. 클라이언트 측 작업 및 논의/문의 사항도 언급되어 있습니다.

---
### 손동작 배정 기능 동작 테스트.md
이 문서는 손동작 배정 기능의 동작 테스트 케이스를 설명합니다. 테스트 환경 설정 시 `enable-scheduler` 속성을 설정하여 스케줄 배정을 번갈아 설정할 수 있도록 합니다. 테스트는 서버에서만 진행하며, 플레이어 1명 및 N명 케이스에 대해 최초 접속, 2회차 이후 접속, 신규/기존 동작 추가/변경, 스케줄 종료 여부, 실 계정 조건에서의 history 조작 등을 검증합니다. 손 동작, 그레이드, 자세는 한 세트로 변경되므로 개별 체크는 불필요하다고 명시합니다.

---
### 스테이지 세이브 포인트 기능 명세서.md
이 문서는 스테이지 세이브 포인트 기능에 대한 명세서입니다. 서버는 1.5일(테스트 포함 2.5일), 클라이언트는 9일(테스트 포함 9.5일)의 일정을 예상합니다. 데이터베이스 설계는 세이브 포인트를 개별 문서로 저장하거나 최종 세이브 포인트만 유지하는 방안을 고려합니다. 서버 API는 플레이어의 전체 세이브 포인트 조회, 저장, 클리어 기능을 포함합니다. 클라이언트 측에서는 API 연동(전체 조회, 저장, 클리어), Upstairs 데이터 설계 수정(이어하기 시 이벤트 정보 소급 적용, 중간부터 생성), 알 획득/대사 이벤트 제어, 스테이지 진행 정보 팝업, 세이브 포인트 도착 시 저장 및 믹스패널 로그 남기기 등의 로직 구현이 필요합니다. 서버와 클라이언트 간의 역할 분담(체크 포인트 삭제)에 대한 논의 사항도 포함되어 있습니다.

---
### 스토어 결제를 위한 인증서 발급 방법.md
이 문서는 Apple 및 Google 스토어 결제를 위한 인증서 발급 방법을 설명합니다. Apple의 경우 `AppleRootCA-G3.cer` (루트 인증서)와 `AuthKey_~~~.p8` (APN 서비스용 개인 키) 발급 절차를 상세히 안내하며, `.p8` 파일은 한 번만 다운로드 가능하므로 안전한 보관을 강조합니다. Google의 경우 Google Cloud Console에서 서비스 계정 키(JSON)를 생성하고 다운로드하는 방법을 설명합니다. 각 인증서의 역할과 발급 시 유의사항을 명시합니다.

---
### 어니컴 시험인정 측정 방법 및 자사 측정방법(사업계획서).md
이 문서는 어니컴 시험인정 측정 방법과 자사 측정 방법을 비교하여 설명하는 사업계획서입니다. TC1(재활 동작 선별 알고리즘), TC2(재활 동작 수행 스코어링/양손 재활 알고리즘), TC3(재활 동작 인식 모델 개수 점검)의 세 가지 시험 항목에 대해 시험 목표, 어니컴의 시험성적 방법, 그리고 자사의 개발 목표 및 평가 방법을 제시합니다. 자사 평가 방법은 손목 올리기, 주먹 쥐기, 주먹 펴기 등 특정 손동작에 대한 인식 정확도를 측정하며, ROM(Range Of Motion) 기준을 기반으로 장애 상태 및 근육 발달 정도를 분류하고, 각 등급별 반복 테스트를 통해 인식률을 계산합니다. 왼손과 오른손은 별도 동작으로 계산하며, 장애 진단을 받은 어린이 또는 일반인 3명을 대상으로 테스트를 진행합니다.

---
## 외장 SSD 연결 관련 내용 정리.md 요약

이 문서는 M2 맥 스튜디오와 외장 SSD를 활용한 Jenkins 환경 구성에 대한 종합 가이드입니다. 현재 구성(M2 맥 스튜디오 + 1050MB/s 외장 SSD)이 Jenkins 워크로드 처리에 성능 저하 없이 매우 적합하며, 그 근거로 읽기/쓰기 속도, 포트 대역폭, Jenkins 작업 특성을 설명합니다. 외장 SSD 마운트 확인 방법과 Jenkins workspace를 외장 SSD로 이동하고 심볼릭 링크로 연결하는 방법을 제시합니다. 또한, 디스크 절전 모드를 해제하는 세 가지 방법(시스템 설정, `pmset` 명령어, Keep-alive 스크립트)을 상세히 설명합니다. 마지막으로 요약 표를 통해 핵심 내용을 정리합니다.

---
## 외주 - 웹 사이트 관 리.md 요약

이 문서는 `gemgem400` 웹사이트와 잼잼 발달센터 웹사이트의 외주 관리 현황을 정리합니다. `gemgem400` 웹사이트는 개발 마무리 단계이며 도메인 등록 및 검색 엔진 세팅, 미완성 디자인 작업이 필요합니다. 잼잼 발달센터 웹사이트는 도메인 등록 및 검색 엔진 등록이 완료되었고, 3개월간의 유지보수 기간이 남아있습니다. 또한, 스프레드시트 데이터를 JSON으로 변환하여 웹 페이지에 자동 배포하는 `잼잼 sheet To Json Converter` 프로그램의 사용법과 개발 관련 메모(GitHub 레포지토리-Vercel 배포 구조, Vercel 배포를 위한 `gemgem-si` 계정 사용 및 git token 활용)를 설명합니다. 마지막으로 `잼잼400` 영문 페이지 개선 작업에 대한 우선순위 및 고려사항을 언급합니다.

---
## 운동 리포트 기능 문서(메인화면).md 요약

이 문서는 운동 리포트의 메인 화면 기능 구현을 위한 설계 및 API 명세를 다룹니다. 운동 리포트는 언어 자극, 시각 추적, 주의 집중, 지시 수행, 공간 지각, 그리고 Easy/Good/Great 횟수 및 총 횟수 등 일일 기록을 누계하고 보관하는 것을 목표로 합니다. `DailyActivityLog`라는 새로운 데이터 구조를 추가하여 하루에 하나씩 생성되며, 해당 날짜까지의 모든 기록을 누계합니다. `DailyActivityLog`는 `therapyResults` 리스트를 포함하여 당일 연결된 치료 결과를 일괄 호출할 수 있도록 합니다. API는 `POST /children/therapy-results`를 통해 운동 결과를 전송하고, `GET /daily-activity-log/today?playerId='childId'`를 통해 일일 활동 로그를 수신합니다. `POST` 요청 시에는 플레이어 ID, 치료 ID, 스테이지, 동작 ID, 손 방향, 등급, 각 등급별 동작 횟수, 치료 시간, 치료 결과, 비지정 동작 횟수, 언어 자극 횟수, 지시 수행 횟수, 공간 지각 점수, 시각 추적 시간, 집중 시간 등의 정보를 포함합니다. `GET` 요청 시에는 플레이어 ID, 각 활동 로그(언어 자극, 지시 수행, 공간 지각, 시각 추적, 집중 시간), 각 등급별 일일 동작 횟수, 총 동작 횟수, 그리고 주간 동작 횟수(`weeklyMotionCount`)를 반환합니다.

---
## 잼잼 센터 홈페이지 인수인계 문서.md 요약

이 문서는 잼잼 센터 웹사이트의 인수인계를 위한 포괄적인 가이드입니다. 웹사이트는 `gemgem-si` Git 계정을 통해 배포되며, Next.js 14 (App Router), TypeScript, Tailwind CSS, Supabase (BaaS), Google API, Material-UI (Mui), Zod를 기술 스택으로 사용합니다. Supabase 무료 티어는 비활성 프로젝트를 일시 중지하므로 데이터베이스 활성 유지가 중요합니다. 프로젝트 구조는 `app/` (소개, 고객 지원 페이지, API 경로, 라이브러리, UI 구성 요소), `context/` (헤더 상태 관리), `public/` (정적 자산), `utils/` (Supabase 및 Google API 도우미)로 구성됩니다. 로컬 실행 방법과 Vercel을 사용한 자동 배포 프로세스(`feature` 브랜치는 미리보기, `main` 브랜치는 실제 웹사이트 배포)를 설명합니다. 환경 변수는 Vercel 대시보드에서 관리하며, 사용자 지정 스타일링은 `my-app/tailwind.config.ts` 파일에서 정의됩니다.

---
## 잼잼-api 컨벤션.md 요약

이 문서는 백엔드 코드 컨벤션을 정의하며, TypeScript DeepDive 코딩 스타일 가이드를 기반으로 합니다. 주요 내용은 다음과 같습니다:
- **변수명:** 의도를 명확히 드러내도록 작성하며, 과도하게 일반적인 단어 사용을 지양합니다.
- **메서드:** `public`, `private`과 같은 예약어를 명확히 명시하고, `동사 + 목적어` 형태로 작성하며 `by`, `for`, `with`와 같은 전치사를 활용할 수 있습니다. 파라미터는 반드시 타입을 선언하고 `any` 대신 `unknown` 타입을 사용합니다.
- **클래스, 인터페이스, 타입, 네임스페이스, 열거형 이름:** `PascalCase`를 사용합니다.
- **클래스 멤버, 메서드, 인터페이스 멤버, 타입 멤버:** `camelCase`를 사용합니다.
- **인터페이스:** `I` 접두사를 사용하지 않습니다.
- **열거형 멤버:** `PascalCase`를 사용합니다.
- **파일 위치:** `utils` (유틸리티 성격 클래스), `common` (상수, 데코레이터, 가드, 타입), `features` (기능 구성 모듈)로 분류합니다.

---
## 잼잼400 온라인 테스트배드 부하테스트.md 요약

이 문서는 메타버스 테스트 랩의 온라인 테스트배드를 활용한 잼잼400 온라인 테스트배드 부하 테스트 결과를 담고 있습니다. 테스트는 네트워크 전송 기능을 제외하고 AI 부하 모의 테스트 코드를 탑재하여 진행되었습니다. 테스트 기기는 GalaxyTab A8이었으며, 100ms당 인공적인 기기 부하를 설정하여 프레임 변화를 관찰했습니다. 0ms/100ms 설정에서는 27~39프레임 범위에서 20대 프레임 빈도가 적었고, 50ms/100ms에서는 20대 프레임이 30%가량 차지했으며, 100ms/100ms에서는 20대 프레임 빈도가 높았습니다(20대와 30대 7:3). 테스트의 미흡한 부분으로 원격 테스트 환경으로 인한 카메라 미사용 및 미디어파이프 미구동으로 인한 정확한 성능 측정의 한계점을 언급합니다. 결론적으로 피카부랩스에게 전달할 목표 수준은 "갤럭시탭 A8 / 이미지 입력부터 결과 도출까지 50ms 이내"로 잠정 설정했으며, 정확한 측정을 위해 UNISOC T618보다 상급인 g99 탑재 기기(예: 갤럭시탭 A9) 구매를 고려하고 있습니다.

---
## 잼잼400 저사양 기기 플레이 데이터.md 요약

이 문서는 잼잼400 애플리케이션의 해외 진출을 위해 저사양 기기(특히 갤럭시탭 A7 Lite)에서의 성능 개선 필요성을 강조하고, 해당 기기의 성능 분석 및 실험 결과를 제시합니다. 갤럭시탭 A7 Lite는 MediaTek Helio P22T 프로세서를 탑재하고 있으며, Helio G99 대비 Antutu, Geekbench, FP32, 그래픽 FLOPS 등 여러 벤치마크에서 현저히 낮은 성능을 보입니다. 실험은 온디바이스 AI 연산 시간을 모의하기 위해 인위적인 연산 딜레이를 추가하여 진행되었으며, 50ms 딜레이 추가 시 11~13fps가 측정되었고, 딜레이가 없는 순수 FPS 측정에서도 11fps가 유지되었습니다. ML 서버 연결 시 50~150ms의 딜레이가 발생했습니다. 이 문서는 저사양 기기에서의 성능 최적화가 중요한 과제임을 시사합니다.

---
## 잼잼400 홈페이지 인수인계 문서.md 요약

이 문서는 GemGem400 웹사이트의 인수인계를 위한 문서로, 프로젝트 개요, 구조, 주요 기능, 배포 및 로컬 개발 환경 설정 방법을 상세히 설명합니다. 웹사이트는 React, TypeScript, Vite, TailwindCSS를 주요 기술로 사용하며, 다국어 지원, SEO 최적화, EmailJS를 통한 이메일 문의 기능, Vercel을 이용한 자동 배포를 핵심 기능으로 합니다. 프로젝트 구조는 `src/` 폴더 내에 컴포넌트, 페이지, 다국어 설정, 커스텀 훅, 에셋, 스타일, 유틸리티 함수 등으로 구성되어 있습니다. 다국어 지원은 `i18next` 라이브러리를 활용하며 URL 경로를 통해 언어를 동적으로 변경하고, 새로운 언어 추가 방법을 단계별로 안내합니다. SEO 최적화는 `react-helmet-async`, `sitemap.xml`, `robots.txt`, `vercel.json`을 통해 이루어집니다. 이메일 기능은 EmailJS를 사용하며, 보안을 위해 Public 저장소 전환 시 환경 변수 사용을 권장합니다. 배포는 Vercel을 통해 `gemgem-si` 계정으로 `main` 브랜치에 푸시하면 자동 배포됩니다. 로컬 개발 환경 설정 방법과 주요 설정 파일(`package.json`, `vite.config.ts`, `tailwind.config.js`, `tsconfig.json`)에 대한 설명도 포함되어 있습니다.

---
## 전화번호 중복 막기 기능 명세서.md 요약

이 문서는 전화번호 중복 막기 기능 명세서로, 클라이언트 0.5일, 서버 2일의 개발 일정을 예상합니다. 이 기능은 로그인 개선 대신 다중 접근 및 어뷰징 방지를 목표로 합니다. 주요 기능 구현 항목은 전화번호 인증을 1회만 진행하고, 이미 등록된 연락처에 대해서는 인증 작업을 스킵하도록 설정하는 것입니다. API 변동은 없으나, 전화번호가 중복인 경우 `POST /request-random/first`에서 406 Not Acceptable을 반환하도록 추가됩니다. 어드민 기능으로는 연락처 등록(전화번호 검증 스킵 가능) 및 삭제 기능이 포함됩니다. 구조 개선 방안으로, 인증번호는 TTL을 포함한 Redis에 기록하여 자동 관리하고, 무조건 스킵되는 대상은 Redis에 string[] 형태로 TTL 없이 무제한으로 보관하는 것을 제안합니다.

---
## 프로젝트 파일 관리 구조.md 요약

이 문서는 NestJS 프로젝트의 권장 파일 관리 구조(Module-based structure)를 정의하고, 그 이유와 추가 추천 사항을 설명합니다. 권장 구조는 `src` 아래에 `app.module.ts`, `main.ts`, 그리고 `modules` (기능별), `common` (전역 공통 컴포넌트), `config` (환경 설정), `shared` (범용 유틸성 요소) 폴더를 포함합니다. 이러한 구조를 권장하는 이유는 확장성과 유지보수성(모듈 단위 기능 분리), 관심사의 명확한 분리(Controller, Service, Module의 역할 구분), 테스트 용이성(유닛/통합 테스트 작성 용이) 때문입니다. 추가 추천 사항으로는 DTO 활용, Entities 별도 분리, 환경변수 관리, 예외 처리(Filters) 및 검증(Pipes) 도입, `Common` 폴더 활용 등이 있습니다. 각 디렉토리의 역할과 함께 NestJS 공식 문서 및 실무 사례 링크를 제공하여 구조의 근거를 뒷받침합니다.

---
## 핑크퐁 기능 명세서.md 요약

이 문서는 핑크퐁 콘텐츠 개발을 위한 기능 명세서로, 클라이언트 40일, 서버 20일의 일정을 예상합니다. "선생님과 함께 하는 콘텐츠"는 1~2달 일정으로 속도와 B2B 계정을 중요시하며, 센터 테스트 배포 및 최소 비용 결제를 목표로 합니다. 서버 측에서는 센터 선생님의 관리자 계정 로그인, 메인 게임 관리 모듈(중간 저장, 기본 데이터 관리, 동시 저장 구조), 결제 시스템(구독 상품 활용 및 확장), 로깅 및 헬스 체크, CICD 설정이 필요합니다. 클라이언트 측에서는 기존 잼잼400 모듈(UnityShared, GemgemShared) 재활용 및 공용 기능(팝업 UI) 개발, 메인 게임 관리 모듈, 게임 UI View/Controller, VContainer 적용이 필요합니다. 영상 보기, 선긋기, 색칠 공부, 글자 쓰기 게임 추가 및 스토어 연동(애플, 구글 앱 등록)도 포함됩니다. 아이가 많아졌을 때 UI 개선(페이지네이션) 및 아이 통합 시스템 구축도 업데이트 사항으로 언급됩니다. 마지막으로 로그인 체계, 손동작 운동 스케줄, 결제 방식, AI 서버 사용 여부 등에 대한 논의 사항과 향후 폴더 구조 및 .NET 프로젝트 생성 계획을 제시합니다.

---
## 회원가입 API 순서 정리 , 개선.md 요약

이 문서는 회원가입 API의 기존 순서와 개선 방안을 제시합니다. 기존 로컬, 구글, 애플 회원가입은 모두 `users/request-random/first` (전화번호 중복 체크), `users/request-random/second` (인증번호 확인) API를 거친 후, 로컬은 `POST users`, 구글/애플은 `POST auth/google` 또는 `POST auth/apple`을 통해 최종 회원가입 및 로그인 토큰을 발급받는 구조입니다. 개선안(버전 2)은 회원가입 로직을 `POST users` (기본 데이터 생성)와 `POST users/more-data` (확장 데이터 생성, 전화번호/국가 코드 추가)로 분리합니다. `POST users/more-data` 호출 시에는 전화번호 중복 체크를 수행하고 새로운 토큰을 발행합니다. `auth/apple/callback` API는 Apple 로그인 시 Apple 서버로부터 인증 코드를 받아 사용자 정보를 검증하고 JWT 토큰을 발급하는 데 사용됩니다.

---
## api 서버 로깅 테스트.md 요약

이 문서는 API 서버 로깅의 정상 동작 여부를 판단하기 위한 테스트 결과 및 개선 방안을 다룹니다. 테스트 결과, 로깅 시 큐가 정상 처리되기 전에 로그 차이가 있을 수 있으나, 약 1초 미만의 인터벌 이후에는 정상적으로 처리됨을 확인했습니다. Discord 로깅의 경우, 요청이 늘어나면 Discord의 Rate limit에 부딪혀 로그 누락이 발생함을 발견했습니다. 테스트 환경은 K6를 활용한 커스텀 포인트 연결, `정상`, `http exception`, `internal error`, `unknown error` 케이스 반복 수행, 자체 환경 및 dev 환경에서의 테스트 비교로 구성되었습니다. Discord API 테스트에서는 100회 수행 시 50번째부터 누락이 발생하며 Rate Limit 문제가 확인되었습니다. 개선 방향으로 Bullmq 라이브러리를 활용한 큐 관리, 백그라운드 처리, 에러 대응 및 큐 딜레이 기능 추가를 통해 100% 완벽하게 로그를 처리할 수 있음을 확인했습니다(처리 시 딜레이 발생 가능).

---
## api 서버 gzip 해제.md 요약

이 문서는 API 서버의 로그 파일(`log.gz`) 압축 해제 및 압축 방법에 대한 간단한 가이드입니다. 로그 파일은 하루가 지나면 `log.gz`로 압축되어 관리되므로, 내용을 확인하려면 압축을 해제해야 합니다. `gzip` 명령어를 사용하여 파일을 압축(`gzip {압축할 파일 명}`)하거나 압축을 해제(`gzip -d {압축 파일 명.gz}`)할 수 있습니다. `gzip`이 설치되어 있지 않은 경우 `sudo apt install gzip` 명령어로 설치할 수 있습니다.

---
## AWS 기초 교육 자료.md 요약

이 문서는 AWS 기초 교육 자료로, 솔트웨어에서 제공하는 AWS Compute Overview, AWS Network Overview, EC2 Session Hands-on Lab, RDS Session Hands-on Lab, VPC Session Hands-on Lab PDF 파일들을 포함하고 있습니다. 이 자료들은 AWS의 컴퓨팅, 네트워킹, 그리고 주요 서비스인 EC2, RDS, VPC에 대한 기본적인 이해와 실습을 돕기 위한 목적으로 보입니다.

---
## K-Culture R&D 연구노트.md 요약

이 문서는 K-Culture R&D 연구노트의 방향 및 계획을 정리한 문서입니다. 주요 내용은 연구노트 주제(12월 개요) 작성, 성적서 작업 준비, 스테이지 내용을 연구노트에 포함하는 것입니다. 2025년 기준 연구 계획 이미지를 포함하며, AI를 통해 도출된 활동들을 연구자 역할에 맞춰 균등하게 분배했음을 언급합니다. 담당자 픽스, 연구노트 제목 검증 및 자료 수집, 내용 생성이 해야 할 일로 정리되어 있습니다.

---
## k6 부하 테스트, api-prod.md 요약

이 문서는 `k6`를 활용한 API 서버(api-prod)의 부하 테스트(Stress Test)에 대한 문서입니다. 서버의 부하 처리 능력을 파악하고 AWS 스펙에 맞춰 처리 가능한 수준을 확인하는 것이 목적입니다. 도커 환경, `k6` 설치, MongoDB 데이터 복원 등의 전제 조건이 필요하며, `k6`를 사용하는 이유로 JavaScript 기반의 시나리오 작성 용이성을 꼽습니다. 테스트 코드 구조(setup 함수: 로그인 및 토큰 반환, default 함수: 데이터 전송 요청)와 테스트 환경 구축 방법(sysbench를 통한 CPU 성능 측정 및 docker run 시 하드웨어 제약 설정, docker-compose를 통한 DB 설정, `build-and-test-k6.sh` 스크립트 실행)을 상세히 설명합니다. 2024년 7월 17일 테스트 결과, CPU 1v/Mem 2GB 기준 약 300명 동시 접속 허용, 메모리 문제 없음이 확인되었습니다. 2024년 11월 20일 테스트에서는 CPU 성능이 약 3배 향상되었으며, 단순 DB 데이터 읽기 시 2000명, 복잡한 쓰기 시 500명까지 안전하게 처리 가능함을 확인했습니다. 국내 서버의 반응 속도가 AppRunner보다 월등히 빠르며, 캐시 및 오토 스케일링 적용 시 4-5000명 동시 접속도 가능할 것으로 예상합니다. 마지막으로 `k6` 설치 및 실행 방법, 결과 분석, 옵션, 고급 기능, 다른 도구와의 비교, 사용 팁, 문제 해결 방법 등을 부록으로 제공합니다.

---
## ML 서버 개선 방안 및 대용량 설계.md 요약

이 문서는 ML 서버의 현 상황(동시 접속자 10명 초과 시 응답 속도 저하, 높은 서버 비용)과 구조적 한계(전처리 과정의 리소스 소모, Latency 문제, Auto Scaling의 한계)를 진단하고, 이에 대한 단기 및 장기 개선 방안을 제안합니다. 단기 방안으로는 웜풀 적용(비용 최소화), 스케일업 기준 구체화(8명 선에서 신규 서버 스케일), Pre-Connection Probe 구조 도입(최초 연결 시 서버 상태 확인 및 접속 허가/거부, Auto Scaling 연동)을 제시합니다. Pre-Connection Probe는 서버 안정성 향상 및 유저 접속 이슈 개선에 장점이 있으나, 클라이언트 작업이 필요하고 서버당 수용량 변화는 없습니다. 중기 방안으로는 전처리 제거(이미지 생성, 미디어파이프 좌표 추출)를 통해 서버 성능을 3~4배 향상시키고 비용을 절감할 수 있으나, 클라이언트-서버 양쪽 작업 및 온디바이스 연동이 필요합니다. 장기 방안으로는 근본적인 최대 스펙 최적화를 위해 소켓 관리, 메시지 큐, 추론 워커를 분리하여 모든 서버가 독립적으로 수평 확장 가능하고 필요한 부분만 스케일업하는 아키텍처 개편을 제안합니다. 이는 대규모 서비스에 적합하나 초기 설계 난이도 및 운영 복잡성이 증가합니다.

---
## ML 서버 성능 테스트.md 요약

이 문서는 ML 서버의 성능 테스트 결과를 상세히 분석한 문서입니다. 시험 환경은 AWS EC2 `m6i.2xlarge` 인스턴스(8vCPU, 32GiB 메모리)와 Locust를 활용한 부하 측정 도구로 구성되었습니다. 시험 목표는 단일 인스턴스의 최대 유저 처리 성능 파악 및 Auto Scaling으로 해결 불가능한 초기 딜레이 문제 개선 인사이트 도출입니다. 주요 시험 결과는 1~3명(RPS 10~30)은 안정적, 5명(RPS 50)부터 CPU 부하 시작, 10명(RPS 100)은 병목 직전, 11명(RPS 110)은 CPU 임계 진입 및 성능 저하 가능성을 보였습니다. 인사이트로는 11명까지 리소스 처리 가능하나 응답 속도 저하 발생, 코어 수의 중요성, 메모리 여유, Scalable 지표(CPU 54% 또는 RX 7MiB/s), 서버당 접속 임계점 설정 필요성, `c6i.2xlarge`로 비용 절감 가능성, 전처리 과정 제거의 중요성을 제시합니다. Locust 테스터기 이슈와 AWS NetworkIn 지표 체킹 시 내부 전송량과의 차이점도 설명합니다.

---
## ML 서버 auto scaling 서버 구성.md 요약

이 문서는 2025년 5월 13일 "새롭게하소서" 방송에 대응하기 위한 ML 서버 Auto Scaling 구성 방법을 설명합니다. 주요 내용은 다음과 같습니다:
- **밑작업:** `pm2`를 사용하여 서버가 부팅 시 자동으로 시작되도록 설정하고 (`pm2 start`, `pm2 save`, `pm2 startup`), 현재 최신 이미지(`gemgemRecognizer-2025-05-13`)를 생성합니다.
- **Auto Scaling 설정:** EC2 대시보드에서 Launch Template을 생성하여 시작 템플릿을 설정하고, Auto Scaling Group을 생성하여 기존 ALB Target Group에 연결합니다. Desired, Min, Max 인스턴스 수를 설정하고 Scaling Policy를 정의합니다.

---
## NAS 관련 파악 사항 정리.md 요약

이 문서는 NAS(Network Attached Storage) 접속 방식에 대한 파악 사항을 정리합니다. NAS는 시놀로지에서 제공하는 QuickConnect 기능과 전통적인 DDNS 기능을 통해 접속할 수 있습니다. QuickConnect는 고정 ID를 통해 시놀로지 서버를 거쳐 접속하는 방식이며, DDNS는 도메인을 할당받아 포트포워딩 작업이 필요합니다. NAS는 기본적으로 외부 공개 IP를 자동으로 인식하지만, 해당 건물의 보안 설정에 따라 포트포워딩 설정이 필요합니다.

---
## NestJS 전역 모듈, 전역 프로바이더.md 요약

이 문서는 NestJS에서 `AppModule`의 `providers` 배열에 서비스를 추가하는 것의 의미와 전역 프로바이더 설정 시 발생할 수 있는 문제점 및 해결 방법을 설명합니다. `AppModule`에 등록된 서비스는 애플리케이션 전체에서 사용 가능한 전역 프로바이더가 되며, 싱글톤 인스턴스로 생성됩니다. 이는 모듈에 속하지 않는 유틸리티나 공통 서비스에 적합합니다. 하지만 모든 서비스를 `AppModule`에 등록하는 것은 권장되지 않습니다. 전역 프로바이더 설정에도 불구하고 `import`가 필요한 경우, 순환 의존성, 모듈 로딩 순서, `@Global()` 데코레이터 누락, `exports` 배열 누락, 서비스 정의 위치, NestJS 버전 문제 등이 원인일 수 있으며, 각 문제에 대한 해결책을 제시합니다. 결론적으로, 서비스가 정의된 모듈을 `@Global()` 데코레이터로 전역 모듈화하면 `AppModule`에서 해당 모듈을 사용한 뒤 다른 모듈에서 `import` 없이 기능을 주입받아 사용할 수 있습니다.

---
## R&D 연간 연구 목표 및 연구노트 초안.md 요약

이 문서는 R&D 연간 연구 목표 및 연구노트 초안을 다룹니다. 대시보드 연간 목표와 연도별 K-Culture 및 TIPS 연구노트 링크를 포함합니다. 연구노트 작성 시 AI를 통해 활동을 도출하고 연구자 역할에 맞춰 균등 분배했음을 언급하며, 담당자 픽스, 연구노트 제목 검증 및 자료 수집, 내용 생성이 해야 할 일로 정리되어 있습니다. 2차 실제 연구노트 작성 작업은 작년 12월 내용 작업, 업무 분배 및 자료 공수, 자료 기반 개요 및 내용 문서화, 구성원 일정 확인 및 분배 작성, 문서 정리 및 제출 마무리로 구성되며, 9월 말 1차 마무리, 11월 말 2차 마무리를 목표로 합니다. TTA 시험 인증 관련 인수인계 사항도 추가 참고사항으로 언급됩니다.

---
## TIPS R&D 연구노트.md 요약

이 문서는 TIPS R&D 연구노트와 관련된 이미지 자료들을 포함하고 있습니다. 구체적인 텍스트 내용은 없지만, 첨부된 스크린샷들을 통해 연구노트의 시각적인 구성과 포함될 내용의 일부를 짐작할 수 있습니다.

---
## TTA 인증 관련 인수인계 사항.md 요약

이 문서는 TTA 시험 인증 관련 인수인계 사항을 정리한 문서입니다. 1차 논의를 통해 9월 초 시험, 9월 말 마무리 일정이 잠정 확정되었습니다. 핵심 목표는 K-Culture 2년차 과제와 TIPS 2년차 과제에 맞춘 시험성적서 각 1부입니다. 세부 목표로 K-Culture는 분류 인식률 90% 달성(C2, F3, F4 제스처의 장애 분류 정확도), 재활 동작 수행 Scoring 알고리즘 및 양손 재활 알고리즘 개발(C2 85%, F3/F4 75% 정확도), 재활 동작 인식 모델 2개 추가를 포함합니다. TIPS는 ROM 기반 치료/평가 프로토콜 제작 및 AI 모델 개발(H1, H2, B2 80% 정확도), Task 기반 치료/평가 프로토콜 제작 및 객체 인식 AI 모델 개발(자사 평가 기준 40% 성능 지표)을 목표로 합니다. 주요 참고 사항으로 TTA 업무 계약 및 시험성적서 관련 담당자와의 재논의 필요성, AI 하이퍼 파라미터 및 분류 답안지 준비, 시험용 SW 준비를 언급합니다. 현재 당면 상황은 모호한 개념 파악 및 시험 평가를 위한 기획, AI 모델 기반 대응 SW 제작 필요성입니다.

---
## TypeScript & Prisma 타입 가용성 향상 방법 (1).md 요약

이 문서는 TypeScript와 Prisma를 사용할 때 타입 가용성을 향상시키는 두 가지 문제점과 해결 방법을 제시합니다.

**문제 1: 탐색 시 항상 바뀌는 조건을 공통 메서드로 묶는 방법**
Prisma 사용 시 DB 탐색 조건 및 추가 인자들에 대해 매번 메서드를 만들어야 하는 문제점을 해결하기 위해 `Partial<Prisma.UserInclude>`와 같은 Prisma 내장 타입을 활용하여 `findOneById`와 같은 공통 메서드를 유연하게 사용할 수 있도록 합니다. `Partial`은 모든 프로퍼티를 옵셔널로 만들어주어 중첩된 객체에 별도로 적용해야 합니다.

**문제 2: 탐색한 대상 객체가 타입이 다를 때**
`findOneById`와 같이 기본 반환 타입이 `User`인 메서드에서 `include`를 사용하더라도 호출하는 곳에서는 `User` 타입만 사용할 수 있는 문제를 해결합니다. `UserWithChildren`과 같이 `User` 타입에 `children` 속성을 추가하는 방식으로 새로운 타입을 정의하고, 호출하는 곳에서 이 명시적인 타입을 선언함으로써 `include`된 객체의 속성까지 접근할 수 있도록 합니다. 이를 통해 타입 문제를 개별 코드에서 해결하지 않고 중앙에서 관리하여 명료성을 높입니다.

---
## upstairs 개선 작업.md 요약

이 문서는 `UpStairs` 기능 개선 작업에 대한 내용을 다룹니다. 주요 개선 사항은 다음과 같습니다:
- **보상 시스템 변경:** `UpStairs`의 보상(알까기) 주기가 주 단위에서 매일 단위로 변경되며, `Pinkfong` 콘텐츠와 티켓 시스템을 공유합니다. 필수 아이템은 무조건 지급되고, 그 외 아이템은 랜덤하게 나옵니다. 한쪽에서 티켓 사용 시 다른 쪽에서는 사용할 수 없습니다.
- **API 제약:** 기존 API 로직의 구조와 순서는 변경할 수 없으며, 바디의 일부 수정만 가능합니다.
- **스테이지 오픈 정책:** 매일 1개의 스테이지가 열리며, 당일 플레이 시 다음 날 다음 스테이지가 열립니다.
- **`TherapyTicket` 도입:** `UpStairs`와 `VideoPinkfong`이 공통으로 사용하는 티켓 시스템으로, 매일 자정에 1개씩 발급되고 사용 시 소모됩니다. `gameId` 필드를 포함하여 사용 가능한 게임을 명시합니다.
- **API 변경:** `POST /children/:childId/therapy-tickets/use` (티켓 사용) 및 `GET /children/:childId/therapy-tickets/today` (당일 사용 가능 티켓 조회) API가 추가됩니다. 기존 `UpStairs` API는 `TherapyTicket` 시스템과 연동되도록 수정합니다.
- **추가 논의 사항:** `TherapyTicket`의 유효 기간, 발급 시점 및 재발급 정책, 보상 풀 관리 및 아이템 지급 로직 상세화가 필요합니다.

---
## VideoPinkfong 기능.md 요약

이 문서는 `VideoPinkfong` 기능의 구조 및 API 변경 사항을 설명합니다. 핵심 목적은 기존 `UpStairs`와 동일한 로직 안에서 동작하여 최대한 호환성을 유지하는 것입니다.

**주요 변경 및 개선 사항:**
- **StageConfig 개선:** `id`, `type`, `stage`, `extraData`, `itemId` 필드를 포함하는 모듈형 설계로 변경되었습니다. `extraData`는 게임 타입에 따라 다른 구조를 가지며, `VideoPinkfong` 타입의 경우 `videoFileKey`, `videoLength`, `videoTitle`, `videoCategory`, `channelTitle`을 포함합니다.
- **API 엔드포인트:** `GET /stage-configs/type?keyword={type}`를 통해 특정 타입의 모든 스테이지 데이터를 조회할 수 있습니다.
- **Child 개선사항:** `Child` 객체에 `nextUnlockablePinkfongStage`와 `lastPlayedPinkfongStage` 필드가 추가되어 핑크퐁 스테이지 진행 상황을 관리합니다.
- **TherapyTicket APIs:** `GET /children/:childId/therapy-tickets`를 통해 모든 치료 티켓 정보를 조회하고, `GET /children/:childId/therapy-tickets/today`를 통해 당일 사용 가능한 치료 티켓 정보를 조회할 수 있습니다. `TherapyTicket` 객체는 `gameId` 필드를 포함하여 어떤 게임에서 사용 가능한지 명시합니다.

---
# 백엔드 개발자 이직 시 어필 사항 (자체 평가):

  이 프로젝트 경험은 백엔드 개발자로서 다양한 핵심 역량을 효과적으로 어필할 수 있는 강력한 기반을 제공합니다.

1. 확장성 및 성능 최적화 경험 (Scalability & Performance Optimization):
   * ML 서버의 부하 테스트(k6 및 Locust 활용)를 통해 단일 인스턴스의 최대 처리 성능을 파악하고, CPU, 네트워크, 메모리 사용량을 분석하여 병목 지점을 식별한 경험은 대규모 트래픽 처리 역량을 보여줍니다.
   * Auto Scaling 그룹 구성 및 정책 설정, 웜풀 적용, Pre-Connection Probe 구조 도입 제안 등 실제 서비스의 안정성과 비용 효율성을 고려한 아키텍처 개선 경험은 매우 중요합니다.
   * 전처리 과정(이미지 변환, 미디어파이프 좌표 추출) 제거를 통한 서버 성능 극대화 방안을 제시하고, 이를 통해 동시 접속자 수를 3~4배 확보할 수 있음을 분석한 것은 성능 최적화에 대한 깊은 이해를 보여줍니다.
   * m6i.2xlarge에서 c6i.2xlarge로 인스턴스 타입 변경을 제안하며 비용 절감 효과를 분석한 것은 기술적 역량과 비즈니스적 관점을 동시에 갖추고 있음을 어필합니다.
   * 가상 메모리/스왑 설정 최적화 경험은 시스템 리소스 관리에 대한 이해를 보여줍니다.

1. 견고한 API 설계 및 구현 능력 (Robust API Design & Implementation):
   * 결제 시스템(구독 인상, 영수증 검증, 실시간 상태 업데이트, 무료 체험) 및 계정 시스템(로컬, 소셜 로그인 연동, 전화번호 중복 방지) 등 복잡한 비즈니스 로직을 포함하는 API를 설계하고 구현한 경험이 있습니다.
   * TherapyTicket 시스템 도입을 통해 UpStairs와 VideoPinkfong 간의 보상 및 티켓 시스템을 통합하고 API를 개선한 것은 유연하고 확장 가능한 시스템 설계 능력을 보여줍니다.
   * NestJS의 모듈 기반 구조, DTO, Entity, 환경변수 관리, 예외 처리(Filters), 검증(Pipes) 등 프레임워크의 모범사례를 따르고 코드 컨벤션을 준수한 경험은 높은 코드 품질과 유지보수성을 지향함을 나타냅니다.
   * TypeScript와 Prisma를 활용하여 타입 안정성과 코드 가용성을 향상시킨 경험은 최신 기술 스택에 대한 이해와 실무 적용 능력을 보여줍니다.

2. 운영 및 모니터링 역량 (Operations & Monitoring Capabilities):
   * 서버 CICD 배포(AWS ECR, Launch Template, Docker Compose) 경험은 자동화된 배포 파이프라인 구축 및 관리에 대한 이해를 보여줍니다.
   * 로깅 전용 서버 구축 계획, Discord 로깅의 Rate Limit 문제 해결(Bullmq를 활용한 큐 관리) 등 로깅 시스템 개선 경험은 안정적인 서비스 운영에 기여합니다.
   * bmon과 같은 네트워크 모니터링 도구 사용 경험 및 CloudWatch 지표 분석 능력은 시스템 상태를 효과적으로 모니터링하고 문제점을 진단하는 역량을 보여줍니다.
   * 서버 점검 시 클라이언트 접속 제어 기능 구현 경험은 서비스 안정성 확보를 위한 운영적 고려를 보여줍니다.

3. 문제 해결 및 분석 능력 (Problem-Solving & Analytical Skills):
   * 저사양 기기에서의 성능 저하 문제 분석 및 개선 필요성 제기, ML 서버의 Latency 문제 진단 등 복잡한 기술적 문제를 분석하고 해결 방안을 모색한 경험이 풍부합니다.
   * 테스트 베드(Locust)의 한계점을 파악하고 개선 방안을 제시한 것은 테스트 환경에 대한 깊은 이해와 분석 능력을 보여줍니다.
   * R&D 연구노트 작성 및 TTA 인증 관련 업무 경험은 기술 문서화 능력과 연구 개발 프로세스에 대한 이해를 어필합니다.

**백엔드 개발자 이직 어필 요약:** 대규모 트래픽 처리 및 비용 최적화를 위한 ML 서버 아키텍처 개선, 복잡한 결제/계정 API 설계 및 구현, CI/CD 및 모니터링 시스템 구축, 그리고 TypeScript/NestJS 기반의 견고한 백엔드 개발 경험을 보유하고 있습니다.
